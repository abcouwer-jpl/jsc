<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info.cleaned - jpeg-safe/jcmarker.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">jpeg-safe</a> - jcmarker.c<span style="font-size: 80%;"> (source / <a href="jcmarker.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info.cleaned</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">271</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-11-24 12:24:12</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">21</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * jcmarker.c
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 1991-1998, Thomas G. Lane.
<span class="lineNum">       5 </span>            :  * Modified 2003-2019 by Guido Vollbeding.
<span class="lineNum">       6 </span>            :  * This file is part of the Independent JPEG Group's software.
<span class="lineNum">       7 </span>            :  * For conditions of distribution and use, see the accompanying README file.
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * This file contains routines to write JPEG datastream markers.
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #define JPEG_INTERNALS
<span class="lineNum">      13 </span>            : #include &quot;jinclude.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;jpeglib.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : typedef enum {                  /* JPEG marker codes */
<span class="lineNum">      18 </span>            :   M_SOF0  = 0xc0,
<span class="lineNum">      19 </span>            :   M_SOF1  = 0xc1,
<span class="lineNum">      20 </span>            :   M_SOF2  = 0xc2,
<span class="lineNum">      21 </span>            :   M_SOF3  = 0xc3,
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            :   M_SOF5  = 0xc5,
<span class="lineNum">      24 </span>            :   M_SOF6  = 0xc6,
<span class="lineNum">      25 </span>            :   M_SOF7  = 0xc7,
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            :   M_JPG   = 0xc8,
<span class="lineNum">      28 </span>            :   M_SOF9  = 0xc9,
<span class="lineNum">      29 </span>            :   M_SOF10 = 0xca,
<span class="lineNum">      30 </span>            :   M_SOF11 = 0xcb,
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            :   M_SOF13 = 0xcd,
<span class="lineNum">      33 </span>            :   M_SOF14 = 0xce,
<span class="lineNum">      34 </span>            :   M_SOF15 = 0xcf,
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            :   M_DHT   = 0xc4,
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            :   M_DAC   = 0xcc,
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            :   M_RST0  = 0xd0,
<span class="lineNum">      41 </span>            :   M_RST1  = 0xd1,
<span class="lineNum">      42 </span>            :   M_RST2  = 0xd2,
<span class="lineNum">      43 </span>            :   M_RST3  = 0xd3,
<span class="lineNum">      44 </span>            :   M_RST4  = 0xd4,
<span class="lineNum">      45 </span>            :   M_RST5  = 0xd5,
<span class="lineNum">      46 </span>            :   M_RST6  = 0xd6,
<span class="lineNum">      47 </span>            :   M_RST7  = 0xd7,
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   M_SOI   = 0xd8,
<span class="lineNum">      50 </span>            :   M_EOI   = 0xd9,
<span class="lineNum">      51 </span>            :   M_SOS   = 0xda,
<span class="lineNum">      52 </span>            :   M_DQT   = 0xdb,
<span class="lineNum">      53 </span>            :   M_DNL   = 0xdc,
<span class="lineNum">      54 </span>            :   M_DRI   = 0xdd,
<span class="lineNum">      55 </span>            :   M_DHP   = 0xde,
<span class="lineNum">      56 </span>            :   M_EXP   = 0xdf,
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :   M_APP0  = 0xe0,
<span class="lineNum">      59 </span>            :   M_APP1  = 0xe1,
<span class="lineNum">      60 </span>            :   M_APP2  = 0xe2,
<span class="lineNum">      61 </span>            :   M_APP3  = 0xe3,
<span class="lineNum">      62 </span>            :   M_APP4  = 0xe4,
<span class="lineNum">      63 </span>            :   M_APP5  = 0xe5,
<span class="lineNum">      64 </span>            :   M_APP6  = 0xe6,
<span class="lineNum">      65 </span>            :   M_APP7  = 0xe7,
<span class="lineNum">      66 </span>            :   M_APP8  = 0xe8,
<span class="lineNum">      67 </span>            :   M_APP9  = 0xe9,
<span class="lineNum">      68 </span>            :   M_APP10 = 0xea,
<span class="lineNum">      69 </span>            :   M_APP11 = 0xeb,
<span class="lineNum">      70 </span>            :   M_APP12 = 0xec,
<span class="lineNum">      71 </span>            :   M_APP13 = 0xed,
<span class="lineNum">      72 </span>            :   M_APP14 = 0xee,
<span class="lineNum">      73 </span>            :   M_APP15 = 0xef,
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :   M_JPG0  = 0xf0,
<span class="lineNum">      76 </span>            :   M_JPG8  = 0xf8,
<span class="lineNum">      77 </span>            :   M_JPG13 = 0xfd,
<span class="lineNum">      78 </span>            :   M_COM   = 0xfe,
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :   M_TEM   = 0x01,
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            :   M_ERROR = 0x100
<span class="lineNum">      83 </span>            : } JPEG_MARKER;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : /* Private state */
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : typedef struct {
<span class="lineNum">      89 </span>            :   struct jpeg_marker_writer pub; /* public fields */
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :   unsigned int last_restart_interval; /* last DRI value emitted; 0 after SOI */
<span class="lineNum">      92 </span>            : } my_marker_writer;
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : typedef my_marker_writer * my_marker_ptr;
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : /*
<span class="lineNum">      98 </span>            :  * Basic output routines.
<span class="lineNum">      99 </span>            :  *
<span class="lineNum">     100 </span>            :  * Note that we do not support suspension while writing a marker.
<span class="lineNum">     101 </span>            :  * Therefore, an application using suspension must ensure that there is
<span class="lineNum">     102 </span>            :  * enough buffer space for the initial markers (typ. 600-700 bytes) before
<span class="lineNum">     103 </span>            :  * calling jpeg_start_compress, and enough space to write the trailing EOI
<span class="lineNum">     104 </span>            :  * (a few bytes) before calling jpeg_finish_compress.  Multipass compression
<span class="lineNum">     105 </span>            :  * modes are not supported at all with suspension, so those two are the only
<span class="lineNum">     106 </span>            :  * points where markers will be written.
<span class="lineNum">     107 </span>            :  */
<a name="108"><span class="lineNum">     108 </span>            : </a>
<span class="lineNum">     109 </span>            : LOCAL(void)
<span class="lineNum">     110 </span><span class="lineNoCov">          0 : emit_byte (j_compress_ptr cinfo, int val)</span>
<span class="lineNum">     111 </span>            : /* Emit a byte */
<span class="lineNum">     112 </span>            : {
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   struct jpeg_destination_mgr * dest = cinfo-&gt;dest;</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   *(dest-&gt;next_output_byte)++ = (JOCTET) val;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   if (--dest-&gt;free_in_buffer == 0) {</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     if (! (*dest-&gt;empty_output_buffer) (cinfo))</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :       ERREXIT(cinfo, JERR_CANT_SUSPEND);</span>
<span class="lineNum">     119 </span>            :   }
<span class="lineNum">     120 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     121 </span>            : 
<a name="122"><span class="lineNum">     122 </span>            : </a>
<span class="lineNum">     123 </span>            : LOCAL(void)
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : emit_marker (j_compress_ptr cinfo, JPEG_MARKER mark)</span>
<span class="lineNum">     125 </span>            : /* Emit a marker code */
<span class="lineNum">     126 </span>            : {
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0xFF);</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, (int) mark);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     130 </span>            : 
<a name="131"><span class="lineNum">     131 </span>            : </a>
<span class="lineNum">     132 </span>            : LOCAL(void)
<span class="lineNum">     133 </span><span class="lineNoCov">          0 : emit_2bytes (j_compress_ptr cinfo, int value)</span>
<span class="lineNum">     134 </span>            : /* Emit a 2-byte integer; these are always MSB first in JPEG files */
<span class="lineNum">     135 </span>            : {
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, (value &gt;&gt; 8) &amp; 0xFF);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, value &amp; 0xFF);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : /*
<span class="lineNum">     142 </span>            :  * Routines to write specific marker types.
<span class="lineNum">     143 </span>            :  */
<a name="144"><span class="lineNum">     144 </span>            : </a>
<span class="lineNum">     145 </span>            : LOCAL(int)
<span class="lineNum">     146 </span><span class="lineNoCov">          0 : emit_dqt (j_compress_ptr cinfo, int index)</span>
<span class="lineNum">     147 </span>            : /* Emit a DQT marker */
<span class="lineNum">     148 </span>            : /* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */
<span class="lineNum">     149 </span>            : {
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   JQUANT_TBL * qtbl = cinfo-&gt;quant_tbl_ptrs[index];</span>
<span class="lineNum">     151 </span>            :   int prec;
<span class="lineNum">     152 </span>            :   int i;
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   if (qtbl == NULL)</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, index);</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   prec = 0;</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt;= cinfo-&gt;lim_Se; i++) {</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     if (qtbl-&gt;quantval[cinfo-&gt;natural_order[i]] &gt; 255)</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :       prec = 1;</span>
<span class="lineNum">     161 </span>            :   }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   if (! qtbl-&gt;sent_table) {</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     emit_marker(cinfo, M_DQT);</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     emit_2bytes(cinfo,</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :       prec ? cinfo-&gt;lim_Se * 2 + 2 + 1 + 2 : cinfo-&gt;lim_Se + 1 + 1 + 2);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, index + (prec&lt;&lt;4));</span>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt;= cinfo-&gt;lim_Se; i++) {</span>
<span class="lineNum">     172 </span>            :       /* The table entries must be emitted in zigzag order. */
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       unsigned int qval = qtbl-&gt;quantval[cinfo-&gt;natural_order[i]];</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       if (prec)</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         emit_byte(cinfo, (int) (qval &gt;&gt; 8));</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :       emit_byte(cinfo, (int) (qval &amp; 0xFF));</span>
<span class="lineNum">     177 </span>            :     }
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     qtbl-&gt;sent_table = TRUE;</span>
<span class="lineNum">     180 </span>            :   }
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   return prec;</span>
<span class="lineNum">     183 </span>            : }
<span class="lineNum">     184 </span>            : 
<a name="185"><span class="lineNum">     185 </span>            : </a>
<span class="lineNum">     186 </span>            : LOCAL(void)
<span class="lineNum">     187 </span><span class="lineNoCov">          0 : emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)</span>
<span class="lineNum">     188 </span>            : /* Emit a DHT marker */
<span class="lineNum">     189 </span>            : {
<span class="lineNum">     190 </span>            :   JHUFF_TBL * htbl;
<span class="lineNum">     191 </span>            :   int length, i;
<span class="lineNum">     192 </span>            :   
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   if (is_ac) {</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     htbl = cinfo-&gt;ac_huff_tbl_ptrs[index];</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     index += 0x10;              /* output index has AC bit set */</span>
<span class="lineNum">     196 </span>            :   } else {
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     htbl = cinfo-&gt;dc_huff_tbl_ptrs[index];</span>
<span class="lineNum">     198 </span>            :   }
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   if (htbl == NULL)</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, index);</span>
<span class="lineNum">     202 </span>            :   
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   if (! htbl-&gt;sent_table) {</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     emit_marker(cinfo, M_DHT);</span>
<span class="lineNum">     205 </span>            :     
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     length = 0;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     for (i = 1; i &lt;= 16; i++)</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :       length += htbl-&gt;bits[i];</span>
<span class="lineNum">     209 </span>            :     
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     emit_2bytes(cinfo, length + 2 + 1 + 16);</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, index);</span>
<span class="lineNum">     212 </span>            :     
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     for (i = 1; i &lt;= 16; i++)</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       emit_byte(cinfo, htbl-&gt;bits[i]);</span>
<span class="lineNum">     215 </span>            :     
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; length; i++)</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :       emit_byte(cinfo, htbl-&gt;huffval[i]);</span>
<span class="lineNum">     218 </span>            :     
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     htbl-&gt;sent_table = TRUE;</span>
<span class="lineNum">     220 </span>            :   }
<span class="lineNum">     221 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     222 </span>            : 
<a name="223"><span class="lineNum">     223 </span>            : </a>
<span class="lineNum">     224 </span>            : LOCAL(void)
<span class="lineNum">     225 </span><span class="lineNoCov">          0 : emit_dac (j_compress_ptr cinfo)</span>
<span class="lineNum">     226 </span>            : /* Emit a DAC marker */
<span class="lineNum">     227 </span>            : /* Since the useful info is so small, we want to emit all the tables in */
<span class="lineNum">     228 </span>            : /* one DAC marker.  Therefore this routine does its own scan of the table. */
<span class="lineNum">     229 </span>            : {
<span class="lineNum">     230 </span>            : #ifdef C_ARITH_CODING_SUPPORTED
<span class="lineNum">     231 </span>            :   char dc_in_use[NUM_ARITH_TBLS];
<span class="lineNum">     232 </span>            :   char ac_in_use[NUM_ARITH_TBLS];
<span class="lineNum">     233 </span>            :   int length, i;
<span class="lineNum">     234 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; NUM_ARITH_TBLS; i++)</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     dc_in_use[i] = ac_in_use[i] = 0;</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     compptr = cinfo-&gt;cur_comp_info[i];</span>
<span class="lineNum">     241 </span>            :     /* DC needs no table for refinement scan */
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0)</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       dc_in_use[compptr-&gt;dc_tbl_no] = 1;</span>
<span class="lineNum">     244 </span>            :     /* AC needs no table when not present */
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (cinfo-&gt;Se)</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       ac_in_use[compptr-&gt;ac_tbl_no] = 1;</span>
<span class="lineNum">     247 </span>            :   }
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   length = 0;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; NUM_ARITH_TBLS; i++)</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     length += dc_in_use[i] + ac_in_use[i];</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   if (length) {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     emit_marker(cinfo, M_DAC);</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     emit_2bytes(cinfo, length*2 + 2);</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; NUM_ARITH_TBLS; i++) {</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       if (dc_in_use[i]) {</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         emit_byte(cinfo, i);</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         emit_byte(cinfo, cinfo-&gt;arith_dc_L[i] + (cinfo-&gt;arith_dc_U[i]&lt;&lt;4));</span>
<span class="lineNum">     262 </span>            :       }
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       if (ac_in_use[i]) {</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         emit_byte(cinfo, i + 0x10);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         emit_byte(cinfo, cinfo-&gt;arith_ac_K[i]);</span>
<span class="lineNum">     266 </span>            :       }
<span class="lineNum">     267 </span>            :     }
<span class="lineNum">     268 </span>            :   }
<span class="lineNum">     269 </span>            : #endif /* C_ARITH_CODING_SUPPORTED */
<span class="lineNum">     270 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     271 </span>            : 
<a name="272"><span class="lineNum">     272 </span>            : </a>
<span class="lineNum">     273 </span>            : LOCAL(void)
<span class="lineNum">     274 </span><span class="lineNoCov">          0 : emit_dri (j_compress_ptr cinfo)</span>
<span class="lineNum">     275 </span>            : /* Emit a DRI marker */
<span class="lineNum">     276 </span>            : {
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_DRI);</span>
<span class="lineNum">     278 </span>            :   
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 4);        /* fixed length */</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, (int) cinfo-&gt;restart_interval);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     283 </span>            : 
<a name="284"><span class="lineNum">     284 </span>            : </a>
<span class="lineNum">     285 </span>            : LOCAL(void)
<span class="lineNum">     286 </span><span class="lineNoCov">          0 : emit_lse_ict (j_compress_ptr cinfo)</span>
<span class="lineNum">     287 </span>            : /* Emit an LSE inverse color transform specification marker */
<span class="lineNum">     288 </span>            : {
<span class="lineNum">     289 </span>            :   /* Support only 1 transform */
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;color_transform != JCT_SUBTRACT_GREEN ||</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :       cinfo-&gt;num_components &lt; 3)</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_JPG8);</span>
<span class="lineNum">     295 </span>            :   
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 24);       /* fixed length */</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x0D);       /* ID inverse transform specification */</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, MAXJSAMPLE);       /* MAXTRANS */</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 3);          /* Nt=3 */</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;comp_info[1].component_id);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;comp_info[0].component_id);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;comp_info[2].component_id);</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x80);       /* F1: CENTER1=1, NORM1=0 */</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 0);        /* A(1,1)=0 */</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 0);        /* A(1,2)=0 */</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0);          /* F2: CENTER2=0, NORM2=0 */</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 1);        /* A(2,1)=1 */</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 0);        /* A(2,2)=0 */</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0);          /* F3: CENTER3=0, NORM3=0 */</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 1);        /* A(3,1)=1 */</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 0);        /* A(3,2)=0 */</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     314 </span>            : 
<a name="315"><span class="lineNum">     315 </span>            : </a>
<span class="lineNum">     316 </span>            : LOCAL(void)
<span class="lineNum">     317 </span><span class="lineNoCov">          0 : emit_sof (j_compress_ptr cinfo, JPEG_MARKER code)</span>
<span class="lineNum">     318 </span>            : /* Emit a SOF marker */
<span class="lineNum">     319 </span>            : {
<span class="lineNum">     320 </span>            :   int ci;
<span class="lineNum">     321 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     322 </span>            :   
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, code);</span>
<span class="lineNum">     324 </span>            :   
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 3 * cinfo-&gt;num_components + 2 + 5 + 1); /* length */</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :   /* Make sure image isn't bigger than SOF field can handle */
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   if ((long) cinfo-&gt;jpeg_height &gt; 65535L ||</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :       (long) cinfo-&gt;jpeg_width &gt; 65535L)</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) 65535);</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;data_precision);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, (int) cinfo-&gt;jpeg_height);</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, (int) cinfo-&gt;jpeg_width);</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;num_components);</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :        ci++, compptr++) {</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, compptr-&gt;component_id);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, (compptr-&gt;h_samp_factor &lt;&lt; 4) + compptr-&gt;v_samp_factor);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, compptr-&gt;quant_tbl_no);</span>
<span class="lineNum">     343 </span>            :   }
<span class="lineNum">     344 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     345 </span>            : 
<a name="346"><span class="lineNum">     346 </span>            : </a>
<span class="lineNum">     347 </span>            : LOCAL(void)
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : emit_sos (j_compress_ptr cinfo)</span>
<span class="lineNum">     349 </span>            : /* Emit a SOS marker */
<span class="lineNum">     350 </span>            : {
<span class="lineNum">     351 </span>            :   int i, td, ta;
<span class="lineNum">     352 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     353 </span>            :   
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_SOS);</span>
<span class="lineNum">     355 </span>            :   
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 2 * cinfo-&gt;comps_in_scan + 2 + 1 + 3); /* length */</span>
<span class="lineNum">     357 </span>            :   
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;comps_in_scan);</span>
<span class="lineNum">     359 </span>            :   
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     compptr = cinfo-&gt;cur_comp_info[i];</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, compptr-&gt;component_id);</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :     /* We emit 0 for unused field(s); this is recommended by the P&amp;M text
<span class="lineNum">     365 </span>            :      * but does not seem to be specified in the standard.
<span class="lineNum">     366 </span>            :      */
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :     /* DC needs no table for refinement scan */
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     td = cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0 ? compptr-&gt;dc_tbl_no : 0;</span>
<span class="lineNum">     370 </span>            :     /* AC needs no table when not present */
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     ta = cinfo-&gt;Se ? compptr-&gt;ac_tbl_no : 0;</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, (td &lt;&lt; 4) + ta);</span>
<span class="lineNum">     374 </span>            :   }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;Ss);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;Se);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, (cinfo-&gt;Ah &lt;&lt; 4) + cinfo-&gt;Al);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     380 </span>            : 
<a name="381"><span class="lineNum">     381 </span>            : </a>
<span class="lineNum">     382 </span>            : LOCAL(void)
<span class="lineNum">     383 </span><span class="lineNoCov">          0 : emit_pseudo_sos (j_compress_ptr cinfo)</span>
<span class="lineNum">     384 </span>            : /* Emit a pseudo SOS marker */
<span class="lineNum">     385 </span>            : {
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_SOS);</span>
<span class="lineNum">     387 </span>            :   
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 2 + 1 + 3); /* length */</span>
<span class="lineNum">     389 </span>            :   
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0); /* Ns */</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0); /* Ss */</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;block_size * cinfo-&gt;block_size - 1); /* Se */</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0); /* Ah/Al */</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     396 </span>            : 
<a name="397"><span class="lineNum">     397 </span>            : </a>
<span class="lineNum">     398 </span>            : LOCAL(void)
<span class="lineNum">     399 </span><span class="lineNoCov">          0 : emit_jfif_app0 (j_compress_ptr cinfo)</span>
<span class="lineNum">     400 </span>            : /* Emit a JFIF-compliant APP0 marker */
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span>            :   /*
<span class="lineNum">     403 </span>            :    * Length of APP0 block       (2 bytes)
<span class="lineNum">     404 </span>            :    * Block ID                   (4 bytes - ASCII &quot;JFIF&quot;)
<span class="lineNum">     405 </span>            :    * Zero byte                  (1 byte to terminate the ID string)
<span class="lineNum">     406 </span>            :    * Version Major, Minor       (2 bytes - major first)
<span class="lineNum">     407 </span>            :    * Units                      (1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)
<span class="lineNum">     408 </span>            :    * Xdpu                       (2 bytes - dots per unit horizontal)
<span class="lineNum">     409 </span>            :    * Ydpu                       (2 bytes - dots per unit vertical)
<span class="lineNum">     410 </span>            :    * Thumbnail X size           (1 byte)
<span class="lineNum">     411 </span>            :    * Thumbnail Y size           (1 byte)
<span class="lineNum">     412 </span>            :    */
<span class="lineNum">     413 </span>            :   
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_APP0);</span>
<span class="lineNum">     415 </span>            :   
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1); /* length */</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x4A);       /* Identifier: ASCII &quot;JFIF&quot; */</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x46);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x49);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x46);</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0);</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;JFIF_major_version); /* Version fields */</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;JFIF_minor_version);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, cinfo-&gt;density_unit); /* Pixel size information */</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, (int) cinfo-&gt;X_density);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, (int) cinfo-&gt;Y_density);</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0);          /* No thumbnail image */</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     431 </span>            : 
<a name="432"><span class="lineNum">     432 </span>            : </a>
<span class="lineNum">     433 </span>            : LOCAL(void)
<span class="lineNum">     434 </span><span class="lineNoCov">          0 : emit_adobe_app14 (j_compress_ptr cinfo)</span>
<span class="lineNum">     435 </span>            : /* Emit an Adobe APP14 marker */
<span class="lineNum">     436 </span>            : {
<span class="lineNum">     437 </span>            :   /*
<span class="lineNum">     438 </span>            :    * Length of APP14 block      (2 bytes)
<span class="lineNum">     439 </span>            :    * Block ID                   (5 bytes - ASCII &quot;Adobe&quot;)
<span class="lineNum">     440 </span>            :    * Version Number             (2 bytes - currently 100)
<span class="lineNum">     441 </span>            :    * Flags0                     (2 bytes - currently 0)
<span class="lineNum">     442 </span>            :    * Flags1                     (2 bytes - currently 0)
<span class="lineNum">     443 </span>            :    * Color transform            (1 byte)
<span class="lineNum">     444 </span>            :    *
<span class="lineNum">     445 </span>            :    * Although Adobe TN 5116 mentions Version = 101, all the Adobe files
<span class="lineNum">     446 </span>            :    * now in circulation seem to use Version = 100, so that's what we write.
<span class="lineNum">     447 </span>            :    *
<span class="lineNum">     448 </span>            :    * We write the color transform byte as 1 if the JPEG color space is
<span class="lineNum">     449 </span>            :    * YCbCr, 2 if it's YCCK, 0 otherwise.  Adobe's definition has to do with
<span class="lineNum">     450 </span>            :    * whether the encoder performed a transformation, which is pretty useless.
<span class="lineNum">     451 </span>            :    */
<span class="lineNum">     452 </span>            :   
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_APP14);</span>
<span class="lineNum">     454 </span>            :   
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 2 + 5 + 2 + 2 + 2 + 1); /* length */</span>
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x41);       /* Identifier: ASCII &quot;Adobe&quot; */</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x64);</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x6F);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x62);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, 0x65);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 100);      /* Version */</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 0);        /* Flags0 */</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, 0);        /* Flags1 */</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :   switch (cinfo-&gt;jpeg_color_space) {</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   case JCS_YCbCr:</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, 1);        /* Color transform = 1 */</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   case JCS_YCCK:</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, 2);        /* Color transform = 2 */</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   default:</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     emit_byte(cinfo, 0);        /* Color transform = 0 */</span>
<span class="lineNum">     474 </span>            :   }
<span class="lineNum">     475 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : /*
<span class="lineNum">     479 </span>            :  * These routines allow writing an arbitrary marker with parameters.
<span class="lineNum">     480 </span>            :  * The only intended use is to emit COM or APPn markers after calling
<span class="lineNum">     481 </span>            :  * write_file_header and before calling write_frame_header.
<span class="lineNum">     482 </span>            :  * Other uses are not guaranteed to produce desirable results.
<span class="lineNum">     483 </span>            :  * Counting the parameter bytes properly is the caller's responsibility.
<span class="lineNum">     484 </span>            :  */
<a name="485"><span class="lineNum">     485 </span>            : </a>
<span class="lineNum">     486 </span>            : METHODDEF(void)
<span class="lineNum">     487 </span><span class="lineNoCov">          0 : write_marker_header (j_compress_ptr cinfo, int marker, unsigned int datalen)</span>
<span class="lineNum">     488 </span>            : /* Emit an arbitrary marker header */
<span class="lineNum">     489 </span>            : {
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   if (datalen &gt; (unsigned int) 65533)                /* safety check */</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_BAD_LENGTH);</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, (JPEG_MARKER) marker);</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   emit_2bytes(cinfo, (int) (datalen + 2));      /* total length */</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 : }</span>
<a name="497"><span class="lineNum">     497 </span>            : </a>
<span class="lineNum">     498 </span>            : METHODDEF(void)
<span class="lineNum">     499 </span><span class="lineNoCov">          0 : write_marker_byte (j_compress_ptr cinfo, int val)</span>
<span class="lineNum">     500 </span>            : /* Emit one byte of marker parameters following write_marker_header */
<span class="lineNum">     501 </span>            : {
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   emit_byte(cinfo, val);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : /*
<span class="lineNum">     507 </span>            :  * Write datastream header.
<span class="lineNum">     508 </span>            :  * This consists of an SOI and optional APPn markers.
<span class="lineNum">     509 </span>            :  * We recommend use of the JFIF marker, but not the Adobe marker,
<span class="lineNum">     510 </span>            :  * when using YCbCr or grayscale data.  The JFIF marker is also used
<span class="lineNum">     511 </span>            :  * for other standard JPEG colorspaces.  The Adobe marker is helpful
<span class="lineNum">     512 </span>            :  * to distinguish RGB, CMYK, and YCCK colorspaces.
<span class="lineNum">     513 </span>            :  * Note that an application can write additional header markers after
<span class="lineNum">     514 </span>            :  * jpeg_start_compress returns.
<span class="lineNum">     515 </span>            :  */
<a name="516"><span class="lineNum">     516 </span>            : </a>
<span class="lineNum">     517 </span>            : METHODDEF(void)
<span class="lineNum">     518 </span><span class="lineNoCov">          0 : write_file_header (j_compress_ptr cinfo)</span>
<span class="lineNum">     519 </span>            : {
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   my_marker_ptr marker = (my_marker_ptr) cinfo-&gt;marker;</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_SOI);    /* first the SOI */</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            :   /* SOI is defined to reset restart interval to 0 */
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   marker-&gt;last_restart_interval = 0;</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;write_JFIF_header)      /* next an optional JFIF APP0 */</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     emit_jfif_app0(cinfo);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;write_Adobe_marker) /* next an optional Adobe APP14 */</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     emit_adobe_app14(cinfo);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            : /*
<span class="lineNum">     535 </span>            :  * Write frame header.
<span class="lineNum">     536 </span>            :  * This consists of DQT and SOFn markers,
<span class="lineNum">     537 </span>            :  * a conditional LSE marker and a conditional pseudo SOS marker.
<span class="lineNum">     538 </span>            :  * Note that we do not emit the SOF until we have emitted the DQT(s).
<span class="lineNum">     539 </span>            :  * This avoids compatibility problems with incorrect implementations that
<span class="lineNum">     540 </span>            :  * try to error-check the quant table numbers as soon as they see the SOF.
<span class="lineNum">     541 </span>            :  */
<a name="542"><span class="lineNum">     542 </span>            : </a>
<span class="lineNum">     543 </span>            : METHODDEF(void)
<span class="lineNum">     544 </span><span class="lineNoCov">          0 : write_frame_header (j_compress_ptr cinfo)</span>
<span class="lineNum">     545 </span>            : {
<span class="lineNum">     546 </span>            :   int ci, prec;
<span class="lineNum">     547 </span>            :   boolean is_baseline;
<span class="lineNum">     548 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     549 </span>            :   
<span class="lineNum">     550 </span>            :   /* Emit DQT for each quantization table.
<span class="lineNum">     551 </span>            :    * Note that emit_dqt() suppresses any duplicate tables.
<span class="lineNum">     552 </span>            :    */
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   prec = 0;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :        ci++, compptr++) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     prec += emit_dqt(cinfo, compptr-&gt;quant_tbl_no);</span>
<span class="lineNum">     557 </span>            :   }
<span class="lineNum">     558 </span>            :   /* now prec is nonzero iff there are any 16-bit quant tables. */
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :   /* Check for a non-baseline specification.
<span class="lineNum">     561 </span>            :    * Note we assume that Huffman table numbers won't be changed later.
<span class="lineNum">     562 </span>            :    */
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;arith_code || cinfo-&gt;progressive_mode ||</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :       cinfo-&gt;data_precision != 8 || cinfo-&gt;block_size != DCTSIZE) {</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     is_baseline = FALSE;</span>
<span class="lineNum">     566 </span>            :   } else {
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     is_baseline = TRUE;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :          ci++, compptr++) {</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :       if (compptr-&gt;dc_tbl_no &gt; 1 || compptr-&gt;ac_tbl_no &gt; 1)</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         is_baseline = FALSE;</span>
<span class="lineNum">     572 </span>            :     }
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :     if (prec &amp;&amp; is_baseline) {</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :       is_baseline = FALSE;</span>
<span class="lineNum">     575 </span>            :       /* If it's baseline except for quantizer size, warn the user */
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :       TRACEMS(cinfo, 0, JTRC_16BIT_TABLES);</span>
<span class="lineNum">     577 </span>            :     }
<span class="lineNum">     578 </span>            :   }
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :   /* Emit the proper SOF marker */
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;arith_code) {</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :     if (cinfo-&gt;progressive_mode)</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :       emit_sof(cinfo, M_SOF10); /* SOF code for progressive arithmetic */</span>
<span class="lineNum">     584 </span>            :     else
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       emit_sof(cinfo, M_SOF9);  /* SOF code for sequential arithmetic */</span>
<span class="lineNum">     586 </span>            :   } else {
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     if (cinfo-&gt;progressive_mode)</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :       emit_sof(cinfo, M_SOF2);  /* SOF code for progressive Huffman */</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     else if (is_baseline)</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :       emit_sof(cinfo, M_SOF0);  /* SOF code for baseline implementation */</span>
<span class="lineNum">     591 </span>            :     else
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       emit_sof(cinfo, M_SOF1);  /* SOF code for non-baseline Huffman file */</span>
<span class="lineNum">     593 </span>            :   }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :   /* Check to emit LSE inverse color transform specification marker */
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;color_transform)</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     emit_lse_ict(cinfo);</span>
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            :   /* Check to emit pseudo SOS marker */
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;progressive_mode &amp;&amp; cinfo-&gt;block_size != DCTSIZE)</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     emit_pseudo_sos(cinfo);</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : /*
<span class="lineNum">     606 </span>            :  * Write scan header.
<span class="lineNum">     607 </span>            :  * This consists of DHT or DAC markers, optional DRI, and SOS.
<span class="lineNum">     608 </span>            :  * Compressed data will be written following the SOS.
<span class="lineNum">     609 </span>            :  */
<a name="610"><span class="lineNum">     610 </span>            : </a>
<span class="lineNum">     611 </span>            : METHODDEF(void)
<span class="lineNum">     612 </span><span class="lineNoCov">          0 : write_scan_header (j_compress_ptr cinfo)</span>
<span class="lineNum">     613 </span>            : {
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   my_marker_ptr marker = (my_marker_ptr) cinfo-&gt;marker;</span>
<span class="lineNum">     615 </span>            :   int i;
<span class="lineNum">     616 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;arith_code) {</span>
<span class="lineNum">     619 </span>            :     /* Emit arith conditioning info.  We may have some duplication
<span class="lineNum">     620 </span>            :      * if the file has multiple scans, but it's so small it's hardly
<span class="lineNum">     621 </span>            :      * worth worrying about.
<span class="lineNum">     622 </span>            :      */
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     emit_dac(cinfo);</span>
<span class="lineNum">     624 </span>            :   } else {
<span class="lineNum">     625 </span>            :     /* Emit Huffman tables.
<span class="lineNum">     626 </span>            :      * Note that emit_dht() suppresses any duplicate tables.
<span class="lineNum">     627 </span>            :      */
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :       compptr = cinfo-&gt;cur_comp_info[i];</span>
<span class="lineNum">     630 </span>            :       /* DC needs no table for refinement scan */
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0)</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         emit_dht(cinfo, compptr-&gt;dc_tbl_no, FALSE);</span>
<span class="lineNum">     633 </span>            :       /* AC needs no table when not present */
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :       if (cinfo-&gt;Se)</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         emit_dht(cinfo, compptr-&gt;ac_tbl_no, TRUE);</span>
<span class="lineNum">     636 </span>            :     }
<span class="lineNum">     637 </span>            :   }
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :   /* Emit DRI if required --- note that DRI value could change for each scan.
<span class="lineNum">     640 </span>            :    * We avoid wasting space with unnecessary DRIs, however.
<span class="lineNum">     641 </span>            :    */
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;restart_interval != marker-&gt;last_restart_interval) {</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     emit_dri(cinfo);</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     marker-&gt;last_restart_interval = cinfo-&gt;restart_interval;</span>
<span class="lineNum">     645 </span>            :   }
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :   emit_sos(cinfo);</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : /*
<span class="lineNum">     652 </span>            :  * Write datastream trailer.
<span class="lineNum">     653 </span>            :  */
<a name="654"><span class="lineNum">     654 </span>            : </a>
<span class="lineNum">     655 </span>            : METHODDEF(void)
<span class="lineNum">     656 </span><span class="lineNoCov">          0 : write_file_trailer (j_compress_ptr cinfo)</span>
<span class="lineNum">     657 </span>            : {
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_EOI);</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : /*
<span class="lineNum">     663 </span>            :  * Write an abbreviated table-specification datastream.
<span class="lineNum">     664 </span>            :  * This consists of SOI, DQT and DHT tables, and EOI.
<span class="lineNum">     665 </span>            :  * Any table that is defined and not marked sent_table = TRUE will be
<span class="lineNum">     666 </span>            :  * emitted.  Note that all tables will be marked sent_table = TRUE at exit.
<span class="lineNum">     667 </span>            :  */
<a name="668"><span class="lineNum">     668 </span>            : </a>
<span class="lineNum">     669 </span>            : METHODDEF(void)
<span class="lineNum">     670 </span><span class="lineNoCov">          0 : write_tables_only (j_compress_ptr cinfo)</span>
<span class="lineNum">     671 </span>            : {
<span class="lineNum">     672 </span>            :   int i;
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_SOI);</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; NUM_QUANT_TBLS; i++) {</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     if (cinfo-&gt;quant_tbl_ptrs[i] != NULL)</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       (void) emit_dqt(cinfo, i);</span>
<span class="lineNum">     679 </span>            :   }
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   if (! cinfo-&gt;arith_code) {</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :       if (cinfo-&gt;dc_huff_tbl_ptrs[i] != NULL)</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :         emit_dht(cinfo, i, FALSE);</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :       if (cinfo-&gt;ac_huff_tbl_ptrs[i] != NULL)</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         emit_dht(cinfo, i, TRUE);</span>
<span class="lineNum">     687 </span>            :     }
<span class="lineNum">     688 </span>            :   }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :   emit_marker(cinfo, M_EOI);</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            : /*
<span class="lineNum">     695 </span>            :  * Initialize the marker writer module.
<span class="lineNum">     696 </span>            :  */
<a name="697"><span class="lineNum">     697 </span>            : </a>
<span class="lineNum">     698 </span>            : GLOBAL(void)
<span class="lineNum">     699 </span><span class="lineNoCov">          0 : jinit_marker_writer (j_compress_ptr cinfo)</span>
<span class="lineNum">     700 </span>            : {
<span class="lineNum">     701 </span>            :   my_marker_ptr marker;
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :   /* Create the subobject */
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   marker = (my_marker_ptr) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="lineNum">     705 </span>            :     ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_marker_writer));
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :   cinfo-&gt;marker = &amp;marker-&gt;pub;</span>
<span class="lineNum">     707 </span>            :   /* Initialize method pointers */
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :   marker-&gt;pub.write_file_header = write_file_header;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :   marker-&gt;pub.write_frame_header = write_frame_header;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   marker-&gt;pub.write_scan_header = write_scan_header;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :   marker-&gt;pub.write_file_trailer = write_file_trailer;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   marker-&gt;pub.write_tables_only = write_tables_only;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   marker-&gt;pub.write_marker_header = write_marker_header;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   marker-&gt;pub.write_marker_byte = write_marker_byte;</span>
<span class="lineNum">     715 </span>            :   /* Initialize private state */
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :   marker-&gt;last_restart_interval = 0;</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
