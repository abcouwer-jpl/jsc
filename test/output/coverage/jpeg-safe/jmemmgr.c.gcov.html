<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info.cleaned - jpeg-safe/jmemmgr.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">jpeg-safe</a> - jmemmgr.c<span style="font-size: 80%;"> (source / <a href="jmemmgr.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info.cleaned</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">377</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-11-24 12:24:12</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * jmemmgr.c
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 1991-1997, Thomas G. Lane.
<span class="lineNum">       5 </span>            :  * Modified 2011-2019 by Guido Vollbeding.
<span class="lineNum">       6 </span>            :  * This file is part of the Independent JPEG Group's software.
<span class="lineNum">       7 </span>            :  * For conditions of distribution and use, see the accompanying README file.
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * This file contains the JPEG system-independent memory management
<span class="lineNum">      10 </span>            :  * routines.  This code is usable across a wide variety of machines; most
<span class="lineNum">      11 </span>            :  * of the system dependencies have been isolated in a separate file.
<span class="lineNum">      12 </span>            :  * The major functions provided here are:
<span class="lineNum">      13 </span>            :  *   * pool-based allocation and freeing of memory;
<span class="lineNum">      14 </span>            :  *   * policy decisions about how to divide available memory among the
<span class="lineNum">      15 </span>            :  *     virtual arrays;
<span class="lineNum">      16 </span>            :  *   * control logic for swapping virtual arrays between main memory and
<span class="lineNum">      17 </span>            :  *     backing storage.
<span class="lineNum">      18 </span>            :  * The separate system-dependent file provides the actual backing-storage
<span class="lineNum">      19 </span>            :  * access code, and it contains the policy decision about how much total
<span class="lineNum">      20 </span>            :  * main memory to use.
<span class="lineNum">      21 </span>            :  * This file is system-dependent in the sense that some of its functions
<span class="lineNum">      22 </span>            :  * are unnecessary in some systems.  For example, if there is enough virtual
<span class="lineNum">      23 </span>            :  * memory so that backing storage will never be used, much of the virtual
<span class="lineNum">      24 </span>            :  * array control logic could be removed.  (Of course, if you have that much
<span class="lineNum">      25 </span>            :  * memory then you shouldn't care about a little bit of unused code...)
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #define JPEG_INTERNALS
<span class="lineNum">      29 </span>            : #define AM_MEMORY_MANAGER       /* we define jvirt_Xarray_control structs */
<span class="lineNum">      30 </span>            : #include &quot;jinclude.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;jpeglib.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;jmemsys.h&quot;          /* import the system-dependent declarations */
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #ifndef NO_GETENV
<span class="lineNum">      35 </span>            : #ifndef HAVE_STDLIB_H           /* &lt;stdlib.h&gt; should declare getenv() */
<span class="lineNum">      36 </span>            : extern char * getenv JPP((const char * name));
<span class="lineNum">      37 </span>            : #endif
<span class="lineNum">      38 </span>            : #endif
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : /*
<span class="lineNum">      42 </span>            :  * Some important notes:
<span class="lineNum">      43 </span>            :  *   The allocation routines provided here must never return NULL.
<span class="lineNum">      44 </span>            :  *   They should exit to error_exit if unsuccessful.
<span class="lineNum">      45 </span>            :  *
<span class="lineNum">      46 </span>            :  *   It's not a good idea to try to merge the sarray and barray routines,
<span class="lineNum">      47 </span>            :  *   even though they are textually almost the same, because samples are
<span class="lineNum">      48 </span>            :  *   usually stored as bytes while coefficients are shorts or ints.  Thus,
<span class="lineNum">      49 </span>            :  *   in machines where byte pointers have a different representation from
<span class="lineNum">      50 </span>            :  *   word pointers, the resulting machine code could not be the same.
<span class="lineNum">      51 </span>            :  */
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /*
<span class="lineNum">      55 </span>            :  * Many machines require storage alignment: longs must start on 4-byte
<span class="lineNum">      56 </span>            :  * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
<span class="lineNum">      57 </span>            :  * always returns pointers that are multiples of the worst-case alignment
<span class="lineNum">      58 </span>            :  * requirement, and we had better do so too.
<span class="lineNum">      59 </span>            :  * There isn't any really portable way to determine the worst-case alignment
<span class="lineNum">      60 </span>            :  * requirement.  This module assumes that the alignment requirement is
<span class="lineNum">      61 </span>            :  * multiples of sizeof(ALIGN_TYPE).
<span class="lineNum">      62 </span>            :  * By default, we define ALIGN_TYPE as double.  This is necessary on some
<span class="lineNum">      63 </span>            :  * workstations (where doubles really do need 8-byte alignment) and will work
<span class="lineNum">      64 </span>            :  * fine on nearly everything.  If your machine has lesser alignment needs,
<span class="lineNum">      65 </span>            :  * you can save a few bytes by making ALIGN_TYPE smaller.
<span class="lineNum">      66 </span>            :  * The only place I know of where this will NOT work is certain Macintosh
<span class="lineNum">      67 </span>            :  * 680x0 compilers that define double as a 10-byte IEEE extended float.
<span class="lineNum">      68 </span>            :  * Doing 10-byte alignment is counterproductive because longwords won't be
<span class="lineNum">      69 </span>            :  * aligned well.  Put &quot;#define ALIGN_TYPE long&quot; in jconfig.h if you have
<span class="lineNum">      70 </span>            :  * such a compiler.
<span class="lineNum">      71 </span>            :  */
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : #ifndef ALIGN_TYPE              /* so can override from jconfig.h */
<span class="lineNum">      74 </span>            : #define ALIGN_TYPE  double
<span class="lineNum">      75 </span>            : #endif
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /*
<span class="lineNum">      79 </span>            :  * We allocate objects from &quot;pools&quot;, where each pool is gotten with a single
<span class="lineNum">      80 </span>            :  * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
<span class="lineNum">      81 </span>            :  * overhead within a pool, except for alignment padding.  Each pool has a
<span class="lineNum">      82 </span>            :  * header with a link to the next pool of the same class.
<span class="lineNum">      83 </span>            :  * Small and large pool headers are identical except that the latter's
<span class="lineNum">      84 </span>            :  * link pointer must be FAR on 80x86 machines.
<span class="lineNum">      85 </span>            :  * Notice that the &quot;real&quot; header fields are union'ed with a dummy ALIGN_TYPE
<span class="lineNum">      86 </span>            :  * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple
<span class="lineNum">      87 </span>            :  * of the alignment requirement of ALIGN_TYPE.
<span class="lineNum">      88 </span>            :  */
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : typedef union small_pool_struct * small_pool_ptr;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : typedef union small_pool_struct {
<span class="lineNum">      93 </span>            :   struct {
<span class="lineNum">      94 </span>            :     small_pool_ptr next;        /* next in list of pools */
<span class="lineNum">      95 </span>            :     size_t bytes_used;          /* how many bytes already used within pool */
<span class="lineNum">      96 </span>            :     size_t bytes_left;          /* bytes still available in this pool */
<span class="lineNum">      97 </span>            :   } hdr;
<span class="lineNum">      98 </span>            :   ALIGN_TYPE dummy;             /* included in union to ensure alignment */
<span class="lineNum">      99 </span>            : } small_pool_hdr;
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : typedef union large_pool_struct FAR * large_pool_ptr;
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : typedef union large_pool_struct {
<span class="lineNum">     104 </span>            :   struct {
<span class="lineNum">     105 </span>            :     large_pool_ptr next;        /* next in list of pools */
<span class="lineNum">     106 </span>            :     size_t bytes_used;          /* how many bytes already used within pool */
<span class="lineNum">     107 </span>            :     size_t bytes_left;          /* bytes still available in this pool */
<span class="lineNum">     108 </span>            :   } hdr;
<span class="lineNum">     109 </span>            :   ALIGN_TYPE dummy;             /* included in union to ensure alignment */
<span class="lineNum">     110 </span>            : } large_pool_hdr;
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : /*
<span class="lineNum">     114 </span>            :  * Here is the full definition of a memory manager object.
<span class="lineNum">     115 </span>            :  */
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : typedef struct {
<span class="lineNum">     118 </span>            :   struct jpeg_memory_mgr pub;   /* public fields */
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :   /* Each pool identifier (lifetime class) names a linked list of pools. */
<span class="lineNum">     121 </span>            :   small_pool_ptr small_list[JPOOL_NUMPOOLS];
<span class="lineNum">     122 </span>            :   large_pool_ptr large_list[JPOOL_NUMPOOLS];
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :   /* Since we only have one lifetime class of virtual arrays, only one
<span class="lineNum">     125 </span>            :    * linked list is necessary (for each datatype).  Note that the virtual
<span class="lineNum">     126 </span>            :    * array control blocks being linked together are actually stored somewhere
<span class="lineNum">     127 </span>            :    * in the small-pool list.
<span class="lineNum">     128 </span>            :    */
<span class="lineNum">     129 </span>            :   jvirt_sarray_ptr virt_sarray_list;
<span class="lineNum">     130 </span>            :   jvirt_barray_ptr virt_barray_list;
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :   /* This counts total space obtained from jpeg_get_small/large */
<span class="lineNum">     133 </span>            :   size_t total_space_allocated;
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :   /* alloc_sarray and alloc_barray set this value for use by virtual
<span class="lineNum">     136 </span>            :    * array routines.
<span class="lineNum">     137 </span>            :    */
<span class="lineNum">     138 </span>            :   JDIMENSION last_rowsperchunk; /* from most recent alloc_sarray/barray */
<span class="lineNum">     139 </span>            : } my_memory_mgr;
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : typedef my_memory_mgr * my_mem_ptr;
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : /*
<span class="lineNum">     145 </span>            :  * The control blocks for virtual arrays.
<span class="lineNum">     146 </span>            :  * Note that these blocks are allocated in the &quot;small&quot; pool area.
<span class="lineNum">     147 </span>            :  * System-dependent info for the associated backing store (if any) is hidden
<span class="lineNum">     148 </span>            :  * inside the backing_store_info struct.
<span class="lineNum">     149 </span>            :  */
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : struct jvirt_sarray_control {
<span class="lineNum">     152 </span>            :   JSAMPARRAY mem_buffer;        /* =&gt; the in-memory buffer */
<span class="lineNum">     153 </span>            :   JDIMENSION rows_in_array;     /* total virtual array height */
<span class="lineNum">     154 </span>            :   JDIMENSION samplesperrow;     /* width of array (and of memory buffer) */
<span class="lineNum">     155 </span>            :   JDIMENSION maxaccess;         /* max rows accessed by access_virt_sarray */
<span class="lineNum">     156 </span>            :   JDIMENSION rows_in_mem;       /* height of memory buffer */
<span class="lineNum">     157 </span>            :   JDIMENSION rowsperchunk;      /* allocation chunk size in mem_buffer */
<span class="lineNum">     158 </span>            :   JDIMENSION cur_start_row;     /* first logical row # in the buffer */
<span class="lineNum">     159 </span>            :   JDIMENSION first_undef_row;   /* row # of first uninitialized row */
<span class="lineNum">     160 </span>            :   boolean pre_zero;             /* pre-zero mode requested? */
<span class="lineNum">     161 </span>            :   boolean dirty;                /* do current buffer contents need written? */
<span class="lineNum">     162 </span>            :   boolean b_s_open;             /* is backing-store data valid? */
<span class="lineNum">     163 </span>            :   jvirt_sarray_ptr next;        /* link to next virtual sarray control block */
<span class="lineNum">     164 </span>            :   backing_store_info b_s_info;  /* System-dependent control info */
<span class="lineNum">     165 </span>            : };
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : struct jvirt_barray_control {
<span class="lineNum">     168 </span>            :   JBLOCKARRAY mem_buffer;       /* =&gt; the in-memory buffer */
<span class="lineNum">     169 </span>            :   JDIMENSION rows_in_array;     /* total virtual array height */
<span class="lineNum">     170 </span>            :   JDIMENSION blocksperrow;      /* width of array (and of memory buffer) */
<span class="lineNum">     171 </span>            :   JDIMENSION maxaccess;         /* max rows accessed by access_virt_barray */
<span class="lineNum">     172 </span>            :   JDIMENSION rows_in_mem;       /* height of memory buffer */
<span class="lineNum">     173 </span>            :   JDIMENSION rowsperchunk;      /* allocation chunk size in mem_buffer */
<span class="lineNum">     174 </span>            :   JDIMENSION cur_start_row;     /* first logical row # in the buffer */
<span class="lineNum">     175 </span>            :   JDIMENSION first_undef_row;   /* row # of first uninitialized row */
<span class="lineNum">     176 </span>            :   boolean pre_zero;             /* pre-zero mode requested? */
<span class="lineNum">     177 </span>            :   boolean dirty;                /* do current buffer contents need written? */
<span class="lineNum">     178 </span>            :   boolean b_s_open;             /* is backing-store data valid? */
<span class="lineNum">     179 </span>            :   jvirt_barray_ptr next;        /* link to next virtual barray control block */
<span class="lineNum">     180 </span>            :   backing_store_info b_s_info;  /* System-dependent control info */
<span class="lineNum">     181 </span>            : };
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : #ifdef MEM_STATS                /* optional extra stuff for statistics */
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : LOCAL(void)
<span class="lineNum">     187 </span>            : print_mem_stats (j_common_ptr cinfo, int pool_id)
<span class="lineNum">     188 </span>            : {
<span class="lineNum">     189 </span>            :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
<span class="lineNum">     190 </span>            :   small_pool_ptr shdr_ptr;
<span class="lineNum">     191 </span>            :   large_pool_ptr lhdr_ptr;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   /* Since this is only a debugging stub, we can cheat a little by using
<span class="lineNum">     194 </span>            :    * fprintf directly rather than going through the trace message code.
<span class="lineNum">     195 </span>            :    * This is helpful because message parm array can't handle longs.
<span class="lineNum">     196 </span>            :    */
<span class="lineNum">     197 </span>            :   fprintf(stderr, &quot;Freeing pool %d, total space = %ld\n&quot;,
<span class="lineNum">     198 </span>            :           pool_id, (long) mem-&gt;total_space_allocated);
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :   for (lhdr_ptr = mem-&gt;large_list[pool_id]; lhdr_ptr != NULL;
<span class="lineNum">     201 </span>            :        lhdr_ptr = lhdr_ptr-&gt;hdr.next) {
<span class="lineNum">     202 </span>            :     fprintf(stderr, &quot;  Large chunk used %ld\n&quot;,
<span class="lineNum">     203 </span>            :             (long) lhdr_ptr-&gt;hdr.bytes_used);
<span class="lineNum">     204 </span>            :   }
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   for (shdr_ptr = mem-&gt;small_list[pool_id]; shdr_ptr != NULL;
<span class="lineNum">     207 </span>            :        shdr_ptr = shdr_ptr-&gt;hdr.next) {
<span class="lineNum">     208 </span>            :     fprintf(stderr, &quot;  Small chunk used %ld free %ld\n&quot;,
<span class="lineNum">     209 </span>            :             (long) shdr_ptr-&gt;hdr.bytes_used,
<span class="lineNum">     210 </span>            :             (long) shdr_ptr-&gt;hdr.bytes_left);
<span class="lineNum">     211 </span>            :   }
<span class="lineNum">     212 </span>            : }
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : #endif /* MEM_STATS */
<span class="lineNum">     215 </span>            : 
<a name="216"><span class="lineNum">     216 </span>            : </a>
<span class="lineNum">     217 </span>            : LOCAL(noreturn_t)
<span class="lineNum">     218 </span><span class="lineNoCov">          0 : out_of_memory (j_common_ptr cinfo, int which)</span>
<span class="lineNum">     219 </span>            : /* Report an out-of-memory error and stop execution */
<span class="lineNum">     220 </span>            : /* If we compiled MEM_STATS support, report alloc requests before dying */
<span class="lineNum">     221 </span>            : {
<span class="lineNum">     222 </span>            : #ifdef MEM_STATS
<span class="lineNum">     223 </span>            :   cinfo-&gt;err-&gt;trace_level = 2;    /* force self_destruct to report stats */
<span class="lineNum">     224 </span>            : #endif
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            : /*
<span class="lineNum">     230 </span>            :  * Allocation of &quot;small&quot; objects.
<span class="lineNum">     231 </span>            :  *
<span class="lineNum">     232 </span>            :  * For these, we use pooled storage.  When a new pool must be created,
<span class="lineNum">     233 </span>            :  * we try to get enough space for the current request plus a &quot;slop&quot; factor,
<span class="lineNum">     234 </span>            :  * where the slop will be the amount of leftover space in the new pool.
<span class="lineNum">     235 </span>            :  * The speed vs. space tradeoff is largely determined by the slop values.
<span class="lineNum">     236 </span>            :  * A different slop value is provided for each pool class (lifetime),
<span class="lineNum">     237 </span>            :  * and we also distinguish the first pool of a class from later ones.
<span class="lineNum">     238 </span>            :  * NOTE: the values given work fairly well on both 16- and 32-bit-int
<span class="lineNum">     239 </span>            :  * machines, but may be too small if longs are 64 bits or more.
<span class="lineNum">     240 </span>            :  */
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : static const size_t first_pool_slop[JPOOL_NUMPOOLS] = 
<span class="lineNum">     243 </span>            : {
<span class="lineNum">     244 </span>            :         1600,                   /* first PERMANENT pool */
<span class="lineNum">     245 </span>            :         16000                   /* first IMAGE pool */
<span class="lineNum">     246 </span>            : };
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : static const size_t extra_pool_slop[JPOOL_NUMPOOLS] = 
<span class="lineNum">     249 </span>            : {
<span class="lineNum">     250 </span>            :         0,                      /* additional PERMANENT pools */
<span class="lineNum">     251 </span>            :         5000                    /* additional IMAGE pools */
<span class="lineNum">     252 </span>            : };
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : #define MIN_SLOP  50            /* greater than 0 to avoid futile looping */
<span class="lineNum">     255 </span>            : 
<a name="256"><span class="lineNum">     256 </span>            : </a>
<span class="lineNum">     257 </span>            : METHODDEF(void *)
<span class="lineNum">     258 </span><span class="lineNoCov">          0 : alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)</span>
<span class="lineNum">     259 </span>            : /* Allocate a &quot;small&quot; object */
<span class="lineNum">     260 </span>            : {
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;</span>
<span class="lineNum">     262 </span>            :   small_pool_ptr hdr_ptr, prev_hdr_ptr;
<span class="lineNum">     263 </span>            :   size_t odd_bytes, min_request, slop;
<span class="lineNum">     264 </span>            :   char * data_ptr;
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :   /* Check for unsatisfiable request (do now to ensure no overflow below) */
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   if (sizeofobject &gt; (size_t) MAX_ALLOC_CHUNK - SIZEOF(small_pool_hdr))</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     out_of_memory(cinfo, 1);    /* request exceeds malloc's ability */</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   if (odd_bytes &gt; 0)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :   /* See if space is available in any existing pool */
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   prev_hdr_ptr = NULL;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   hdr_ptr = mem-&gt;small_list[pool_id];</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   while (hdr_ptr != NULL) {</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     if (hdr_ptr-&gt;hdr.bytes_left &gt;= sizeofobject)</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :       break;                    /* found pool with enough space */</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     prev_hdr_ptr = hdr_ptr;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     hdr_ptr = hdr_ptr-&gt;hdr.next;</span>
<span class="lineNum">     285 </span>            :   }
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   /* Time to make a new pool? */
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   if (hdr_ptr == NULL) {</span>
<span class="lineNum">     289 </span>            :     /* min_request is what we need now, slop is what will be leftover */
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     min_request = sizeofobject + SIZEOF(small_pool_hdr);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     if (prev_hdr_ptr == NULL)   /* first pool in class? */</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       slop = first_pool_slop[pool_id];</span>
<span class="lineNum">     293 </span>            :     else
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :       slop = extra_pool_slop[pool_id];</span>
<span class="lineNum">     295 </span>            :     /* Don't ask for more than MAX_ALLOC_CHUNK */
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     if (slop &gt; (size_t) MAX_ALLOC_CHUNK - min_request)</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :       slop = (size_t) MAX_ALLOC_CHUNK - min_request;</span>
<span class="lineNum">     298 </span>            :     /* Try to get space, if fail reduce slop and try again */
<span class="lineNum">     299 </span>            :     for (;;) {
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       if (hdr_ptr != NULL)</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       slop /= 2;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :       if (slop &lt; MIN_SLOP)   /* give up when it gets real small */</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         out_of_memory(cinfo, 2); /* jpeg_get_small failed */</span>
<span class="lineNum">     306 </span>            :     }
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     mem-&gt;total_space_allocated += min_request + slop;</span>
<span class="lineNum">     308 </span>            :     /* Success, initialize the new pool header and add to end of list */
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     hdr_ptr-&gt;hdr.next = NULL;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     hdr_ptr-&gt;hdr.bytes_used = 0;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     hdr_ptr-&gt;hdr.bytes_left = sizeofobject + slop;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     if (prev_hdr_ptr == NULL)   /* first pool in class? */</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :       mem-&gt;small_list[pool_id] = hdr_ptr;</span>
<span class="lineNum">     314 </span>            :     else
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       prev_hdr_ptr-&gt;hdr.next = hdr_ptr;</span>
<span class="lineNum">     316 </span>            :   }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :   /* OK, allocate the object from the current pool */
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   data_ptr += hdr_ptr-&gt;hdr.bytes_used; /* point to place for object */</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   hdr_ptr-&gt;hdr.bytes_used += sizeofobject;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   hdr_ptr-&gt;hdr.bytes_left -= sizeofobject;</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   return (void *) data_ptr;</span>
<span class="lineNum">     325 </span>            : }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : /*
<span class="lineNum">     329 </span>            :  * Allocation of &quot;large&quot; objects.
<span class="lineNum">     330 </span>            :  *
<span class="lineNum">     331 </span>            :  * The external semantics of these are the same as &quot;small&quot; objects,
<span class="lineNum">     332 </span>            :  * except that FAR pointers are used on 80x86.  However the pool
<span class="lineNum">     333 </span>            :  * management heuristics are quite different.  We assume that each
<span class="lineNum">     334 </span>            :  * request is large enough that it may as well be passed directly to
<span class="lineNum">     335 </span>            :  * jpeg_get_large; the pool management just links everything together
<span class="lineNum">     336 </span>            :  * so that we can free it all on demand.
<span class="lineNum">     337 </span>            :  * Note: the major use of &quot;large&quot; objects is in JSAMPARRAY and JBLOCKARRAY
<span class="lineNum">     338 </span>            :  * structures.  The routines that create these structures (see below)
<span class="lineNum">     339 </span>            :  * deliberately bunch rows together to ensure a large request size.
<span class="lineNum">     340 </span>            :  */
<a name="341"><span class="lineNum">     341 </span>            : </a>
<span class="lineNum">     342 </span>            : METHODDEF(void FAR *)
<span class="lineNum">     343 </span><span class="lineNoCov">          0 : alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)</span>
<span class="lineNum">     344 </span>            : /* Allocate a &quot;large&quot; object */
<span class="lineNum">     345 </span>            : {
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;</span>
<span class="lineNum">     347 </span>            :   large_pool_ptr hdr_ptr;
<span class="lineNum">     348 </span>            :   size_t odd_bytes;
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :   /* Check for unsatisfiable request (do now to ensure no overflow below) */
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   if (sizeofobject &gt; (size_t) MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr))</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     out_of_memory(cinfo, 3);    /* request exceeds malloc's ability */</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   if (odd_bytes &gt; 0)</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :   /* Always make a new pool */
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +</span>
<span class="lineNum">     364 </span>            :                                             SIZEOF(large_pool_hdr));
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   if (hdr_ptr == NULL)</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     out_of_memory(cinfo, 4);    /* jpeg_get_large failed */</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   mem-&gt;total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :   /* Success, initialize the new pool header and add to list */
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   hdr_ptr-&gt;hdr.next = mem-&gt;large_list[pool_id];</span>
<span class="lineNum">     371 </span>            :   /* We maintain space counts in each pool header for statistical purposes,
<span class="lineNum">     372 </span>            :    * even though they are not needed for allocation.
<span class="lineNum">     373 </span>            :    */
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   hdr_ptr-&gt;hdr.bytes_used = sizeofobject;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   hdr_ptr-&gt;hdr.bytes_left = 0;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   mem-&gt;large_list[pool_id] = hdr_ptr;</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */</span>
<span class="lineNum">     379 </span>            : }
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : /*
<span class="lineNum">     383 </span>            :  * Creation of 2-D sample arrays.
<span class="lineNum">     384 </span>            :  * The pointers are in near heap, the samples themselves in FAR heap.
<span class="lineNum">     385 </span>            :  *
<span class="lineNum">     386 </span>            :  * To minimize allocation overhead and to allow I/O of large contiguous
<span class="lineNum">     387 </span>            :  * blocks, we allocate the sample rows in groups of as many rows as possible
<span class="lineNum">     388 </span>            :  * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.
<span class="lineNum">     389 </span>            :  * NB: the virtual array control routines, later in this file, know about
<span class="lineNum">     390 </span>            :  * this chunking of rows.  The rowsperchunk value is left in the mem manager
<span class="lineNum">     391 </span>            :  * object so that it can be saved away if this sarray is the workspace for
<span class="lineNum">     392 </span>            :  * a virtual array.
<span class="lineNum">     393 </span>            :  */
<a name="394"><span class="lineNum">     394 </span>            : </a>
<span class="lineNum">     395 </span>            : METHODDEF(JSAMPARRAY)
<span class="lineNum">     396 </span><span class="lineNoCov">          0 : alloc_sarray (j_common_ptr cinfo, int pool_id,</span>
<span class="lineNum">     397 </span>            :               JDIMENSION samplesperrow, JDIMENSION numrows)
<span class="lineNum">     398 </span>            : /* Allocate a 2-D sample array */
<span class="lineNum">     399 </span>            : {
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;</span>
<span class="lineNum">     401 </span>            :   JSAMPARRAY result;
<span class="lineNum">     402 </span>            :   JSAMPROW workspace;
<span class="lineNum">     403 </span>            :   JDIMENSION rowsperchunk, currow, i;
<span class="lineNum">     404 </span>            :   long ltemp;
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :   /* Calculate max # of rows allowed in one allocation chunk */
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   ltemp = (MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr)) /</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :           ((long) samplesperrow * SIZEOF(JSAMPLE));</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   if (ltemp &lt;= 0)</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   if (ltemp &lt; (long) numrows)</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     rowsperchunk = (JDIMENSION) ltemp;</span>
<span class="lineNum">     413 </span>            :   else
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     rowsperchunk = numrows;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   mem-&gt;last_rowsperchunk = rowsperchunk;</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :   /* Get space for row pointers (small object) */
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   result = (JSAMPARRAY) alloc_small(cinfo, pool_id,</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :                                     (size_t) numrows * SIZEOF(JSAMPROW));</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :   /* Get the rows themselves (large objects) */
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   currow = 0;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   while (currow &lt; numrows) {</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :     rowsperchunk = MIN(rowsperchunk, numrows - currow);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :       (size_t) rowsperchunk * (size_t) samplesperrow * SIZEOF(JSAMPLE));</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     for (i = rowsperchunk; i &gt; 0; i--) {</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :       result[currow++] = workspace;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :       workspace += samplesperrow;</span>
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span>            :   }
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     434 </span>            : }
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : /*
<span class="lineNum">     438 </span>            :  * Creation of 2-D coefficient-block arrays.
<span class="lineNum">     439 </span>            :  * This is essentially the same as the code for sample arrays, above.
<span class="lineNum">     440 </span>            :  */
<a name="441"><span class="lineNum">     441 </span>            : </a>
<span class="lineNum">     442 </span>            : METHODDEF(JBLOCKARRAY)
<span class="lineNum">     443 </span><span class="lineNoCov">          0 : alloc_barray (j_common_ptr cinfo, int pool_id,</span>
<span class="lineNum">     444 </span>            :               JDIMENSION blocksperrow, JDIMENSION numrows)
<span class="lineNum">     445 </span>            : /* Allocate a 2-D coefficient-block array */
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;</span>
<span class="lineNum">     448 </span>            :   JBLOCKARRAY result;
<span class="lineNum">     449 </span>            :   JBLOCKROW workspace;
<span class="lineNum">     450 </span>            :   JDIMENSION rowsperchunk, currow, i;
<span class="lineNum">     451 </span>            :   long ltemp;
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :   /* Calculate max # of rows allowed in one allocation chunk */
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   ltemp = (MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr)) /</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :           ((long) blocksperrow * SIZEOF(JBLOCK));</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   if (ltemp &lt;= 0)</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   if (ltemp &lt; (long) numrows)</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     rowsperchunk = (JDIMENSION) ltemp;</span>
<span class="lineNum">     460 </span>            :   else
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     rowsperchunk = numrows;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   mem-&gt;last_rowsperchunk = rowsperchunk;</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :   /* Get space for row pointers (small object) */
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :   result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                                      (size_t) numrows * SIZEOF(JBLOCKROW));</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :   /* Get the rows themselves (large objects) */
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   currow = 0;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   while (currow &lt; numrows) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     rowsperchunk = MIN(rowsperchunk, numrows - currow);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :       (size_t) rowsperchunk * (size_t) blocksperrow * SIZEOF(JBLOCK));</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     for (i = rowsperchunk; i &gt; 0; i--) {</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :       result[currow++] = workspace;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       workspace += blocksperrow;</span>
<span class="lineNum">     477 </span>            :     }
<span class="lineNum">     478 </span>            :   }
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     481 </span>            : }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            : /*
<span class="lineNum">     485 </span>            :  * About virtual array management:
<span class="lineNum">     486 </span>            :  *
<span class="lineNum">     487 </span>            :  * The above &quot;normal&quot; array routines are only used to allocate strip buffers
<span class="lineNum">     488 </span>            :  * (as wide as the image, but just a few rows high).  Full-image-sized buffers
<span class="lineNum">     489 </span>            :  * are handled as &quot;virtual&quot; arrays.  The array is still accessed a strip at a
<span class="lineNum">     490 </span>            :  * time, but the memory manager must save the whole array for repeated
<span class="lineNum">     491 </span>            :  * accesses.  The intended implementation is that there is a strip buffer in
<span class="lineNum">     492 </span>            :  * memory (as high as is possible given the desired memory limit), plus a
<span class="lineNum">     493 </span>            :  * backing file that holds the rest of the array.
<span class="lineNum">     494 </span>            :  *
<span class="lineNum">     495 </span>            :  * The request_virt_array routines are told the total size of the image and
<span class="lineNum">     496 </span>            :  * the maximum number of rows that will be accessed at once.  The in-memory
<span class="lineNum">     497 </span>            :  * buffer must be at least as large as the maxaccess value.
<span class="lineNum">     498 </span>            :  *
<span class="lineNum">     499 </span>            :  * The request routines create control blocks but not the in-memory buffers.
<span class="lineNum">     500 </span>            :  * That is postponed until realize_virt_arrays is called.  At that time the
<span class="lineNum">     501 </span>            :  * total amount of space needed is known (approximately, anyway), so free
<span class="lineNum">     502 </span>            :  * memory can be divided up fairly.
<span class="lineNum">     503 </span>            :  *
<span class="lineNum">     504 </span>            :  * The access_virt_array routines are responsible for making a specific strip
<span class="lineNum">     505 </span>            :  * area accessible (after reading or writing the backing file, if necessary).
<span class="lineNum">     506 </span>            :  * Note that the access routines are told whether the caller intends to modify
<span class="lineNum">     507 </span>            :  * the accessed strip; during a read-only pass this saves having to rewrite
<span class="lineNum">     508 </span>            :  * data to disk.  The access routines are also responsible for pre-zeroing
<span class="lineNum">     509 </span>            :  * any newly accessed rows, if pre-zeroing was requested.
<span class="lineNum">     510 </span>            :  *
<span class="lineNum">     511 </span>            :  * In current usage, the access requests are usually for nonoverlapping
<span class="lineNum">     512 </span>            :  * strips; that is, successive access start_row numbers differ by exactly
<span class="lineNum">     513 </span>            :  * num_rows = maxaccess.  This means we can get good performance with simple
<span class="lineNum">     514 </span>            :  * buffer dump/reload logic, by making the in-memory buffer be a multiple
<span class="lineNum">     515 </span>            :  * of the access height; then there will never be accesses across bufferload
<span class="lineNum">     516 </span>            :  * boundaries.  The code will still work with overlapping access requests,
<span class="lineNum">     517 </span>            :  * but it doesn't handle bufferload overlaps very efficiently.
<span class="lineNum">     518 </span>            :  */
<span class="lineNum">     519 </span>            : 
<a name="520"><span class="lineNum">     520 </span>            : </a>
<span class="lineNum">     521 </span>            : METHODDEF(jvirt_sarray_ptr)
<span class="lineNum">     522 </span><span class="lineNoCov">          0 : request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,</span>
<span class="lineNum">     523 </span>            :                      JDIMENSION samplesperrow, JDIMENSION numrows,
<span class="lineNum">     524 </span>            :                      JDIMENSION maxaccess)
<span class="lineNum">     525 </span>            : /* Request a virtual 2-D sample array */
<span class="lineNum">     526 </span>            : {
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;</span>
<span class="lineNum">     528 </span>            :   jvirt_sarray_ptr result;
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :   /* Only IMAGE-lifetime virtual arrays are currently supported */
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   if (pool_id != JPOOL_IMAGE)</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :   /* get control block */
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,</span>
<span class="lineNum">     536 </span>            :                                           SIZEOF(struct jvirt_sarray_control));
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :   result-&gt;mem_buffer = NULL; /* marks array not yet realized */</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :   result-&gt;rows_in_array = numrows;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   result-&gt;samplesperrow = samplesperrow;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   result-&gt;maxaccess = maxaccess;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   result-&gt;pre_zero = pre_zero;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   result-&gt;b_s_open = FALSE;  /* no associated backing-store object */</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   result-&gt;next = mem-&gt;virt_sarray_list; /* add to list of virtual arrays */</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   mem-&gt;virt_sarray_list = result;</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     548 </span>            : }
<span class="lineNum">     549 </span>            : 
<a name="550"><span class="lineNum">     550 </span>            : </a>
<span class="lineNum">     551 </span>            : METHODDEF(jvirt_barray_ptr)
<span class="lineNum">     552 </span><span class="lineNoCov">          0 : request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,</span>
<span class="lineNum">     553 </span>            :                      JDIMENSION blocksperrow, JDIMENSION numrows,
<span class="lineNum">     554 </span>            :                      JDIMENSION maxaccess)
<span class="lineNum">     555 </span>            : /* Request a virtual 2-D coefficient-block array */
<span class="lineNum">     556 </span>            : {
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;</span>
<span class="lineNum">     558 </span>            :   jvirt_barray_ptr result;
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :   /* Only IMAGE-lifetime virtual arrays are currently supported */
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   if (pool_id != JPOOL_IMAGE)</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */</span>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :   /* get control block */
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,</span>
<span class="lineNum">     566 </span>            :                                           SIZEOF(struct jvirt_barray_control));
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   result-&gt;mem_buffer = NULL; /* marks array not yet realized */</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   result-&gt;rows_in_array = numrows;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   result-&gt;blocksperrow = blocksperrow;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   result-&gt;maxaccess = maxaccess;</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   result-&gt;pre_zero = pre_zero;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   result-&gt;b_s_open = FALSE;  /* no associated backing-store object */</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   result-&gt;next = mem-&gt;virt_barray_list; /* add to list of virtual arrays */</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   mem-&gt;virt_barray_list = result;</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     578 </span>            : }
<span class="lineNum">     579 </span>            : 
<a name="580"><span class="lineNum">     580 </span>            : </a>
<span class="lineNum">     581 </span>            : METHODDEF(void)
<span class="lineNum">     582 </span><span class="lineNoCov">          0 : realize_virt_arrays (j_common_ptr cinfo)</span>
<span class="lineNum">     583 </span>            : /* Allocate the in-memory buffers for any unrealized virtual arrays */
<span class="lineNum">     584 </span>            : {
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;</span>
<span class="lineNum">     586 </span>            :   long bytesperrow, space_per_minheight, maximum_space;
<span class="lineNum">     587 </span>            :   long avail_mem, minheights, max_minheights;
<span class="lineNum">     588 </span>            :   jvirt_sarray_ptr sptr;
<span class="lineNum">     589 </span>            :   jvirt_barray_ptr bptr;
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :   /* Compute the minimum space needed (maxaccess rows in each buffer)
<span class="lineNum">     592 </span>            :    * and the maximum space needed (full image height in each buffer).
<span class="lineNum">     593 </span>            :    * These may be of use to the system-dependent jpeg_mem_available routine.
<span class="lineNum">     594 </span>            :    */
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   space_per_minheight = 0;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   maximum_space = 0;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       bytesperrow = (long) sptr-&gt;samplesperrow * SIZEOF(JSAMPLE);</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       space_per_minheight += (long) sptr-&gt;maxaccess * bytesperrow;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       maximum_space += (long) sptr-&gt;rows_in_array * bytesperrow;</span>
<span class="lineNum">     602 </span>            :     }
<span class="lineNum">     603 </span>            :   }
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     if (bptr-&gt;mem_buffer == NULL) { /* if not realized yet */</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :       bytesperrow = (long) bptr-&gt;blocksperrow * SIZEOF(JBLOCK);</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :       space_per_minheight += (long) bptr-&gt;maxaccess * bytesperrow;</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :       maximum_space += (long) bptr-&gt;rows_in_array * bytesperrow;</span>
<span class="lineNum">     609 </span>            :     }
<span class="lineNum">     610 </span>            :   }
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   if (space_per_minheight &lt;= 0)</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     return;                     /* no unrealized arrays, no work */</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            :   /* Determine amount of memory to actually use; this is system-dependent. */
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                                  (long) mem-&gt;total_space_allocated);</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :   /* If the maximum space needed is available, make all the buffers full
<span class="lineNum">     620 </span>            :    * height; otherwise parcel it out with the same number of minheights
<span class="lineNum">     621 </span>            :    * in each buffer.
<span class="lineNum">     622 </span>            :    */
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   if (avail_mem &gt;= maximum_space)</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     max_minheights = 1000000000L;</span>
<span class="lineNum">     625 </span>            :   else {
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     max_minheights = avail_mem / space_per_minheight;</span>
<span class="lineNum">     627 </span>            :     /* If there doesn't seem to be enough space, try to get the minimum
<span class="lineNum">     628 </span>            :      * anyway.  This allows a &quot;stub&quot; implementation of jpeg_mem_available().
<span class="lineNum">     629 </span>            :      */
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     if (max_minheights &lt;= 0)</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       max_minheights = 1;</span>
<span class="lineNum">     632 </span>            :   }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :   /* Allocate the in-memory buffers and initialize backing store as needed. */
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       minheights = ((long) sptr-&gt;rows_in_array - 1L) / sptr-&gt;maxaccess + 1L;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :       if (minheights &lt;= max_minheights) {</span>
<span class="lineNum">     640 </span>            :         /* This buffer fits in memory */
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :         sptr-&gt;rows_in_mem = sptr-&gt;rows_in_array;</span>
<span class="lineNum">     642 </span>            :       } else {
<span class="lineNum">     643 </span>            :         /* It doesn't fit in memory, create backing store. */
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         sptr-&gt;rows_in_mem = (JDIMENSION) (max_minheights * sptr-&gt;maxaccess);</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         jpeg_open_backing_store(cinfo, &amp; sptr-&gt;b_s_info,</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :                                 (long) sptr-&gt;rows_in_array *</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :                                 (long) sptr-&gt;samplesperrow *</span>
<span class="lineNum">     648 </span>            :                                 (long) SIZEOF(JSAMPLE));
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         sptr-&gt;b_s_open = TRUE;</span>
<span class="lineNum">     650 </span>            :       }
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :       sptr-&gt;mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,</span>
<span class="lineNum">     652 </span>            :                                       sptr-&gt;samplesperrow, sptr-&gt;rows_in_mem);
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :       sptr-&gt;rowsperchunk = mem-&gt;last_rowsperchunk;</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :       sptr-&gt;cur_start_row = 0;</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :       sptr-&gt;first_undef_row = 0;</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :       sptr-&gt;dirty = FALSE;</span>
<span class="lineNum">     657 </span>            :     }
<span class="lineNum">     658 </span>            :   }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     if (bptr-&gt;mem_buffer == NULL) { /* if not realized yet */</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       minheights = ((long) bptr-&gt;rows_in_array - 1L) / bptr-&gt;maxaccess + 1L;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :       if (minheights &lt;= max_minheights) {</span>
<span class="lineNum">     664 </span>            :         /* This buffer fits in memory */
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :         bptr-&gt;rows_in_mem = bptr-&gt;rows_in_array;</span>
<span class="lineNum">     666 </span>            :       } else {
<span class="lineNum">     667 </span>            :         /* It doesn't fit in memory, create backing store. */
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         bptr-&gt;rows_in_mem = (JDIMENSION) (max_minheights * bptr-&gt;maxaccess);</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :         jpeg_open_backing_store(cinfo, &amp; bptr-&gt;b_s_info,</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                                 (long) bptr-&gt;rows_in_array *</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :                                 (long) bptr-&gt;blocksperrow *</span>
<span class="lineNum">     672 </span>            :                                 (long) SIZEOF(JBLOCK));
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :         bptr-&gt;b_s_open = TRUE;</span>
<span class="lineNum">     674 </span>            :       }
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :       bptr-&gt;mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,</span>
<span class="lineNum">     676 </span>            :                                       bptr-&gt;blocksperrow, bptr-&gt;rows_in_mem);
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :       bptr-&gt;rowsperchunk = mem-&gt;last_rowsperchunk;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       bptr-&gt;cur_start_row = 0;</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :       bptr-&gt;first_undef_row = 0;</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :       bptr-&gt;dirty = FALSE;</span>
<span class="lineNum">     681 </span>            :     }
<span class="lineNum">     682 </span>            :   }
<span class="lineNum">     683 </span>            : }
<span class="lineNum">     684 </span>            : 
<a name="685"><span class="lineNum">     685 </span>            : </a>
<span class="lineNum">     686 </span>            : LOCAL(void)
<span class="lineNum">     687 </span><span class="lineNoCov">          0 : do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)</span>
<span class="lineNum">     688 </span>            : /* Do backing store read or write of a virtual sample array */
<span class="lineNum">     689 </span>            : {
<span class="lineNum">     690 </span>            :   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   bytesperrow = (long) ptr-&gt;samplesperrow * SIZEOF(JSAMPLE);</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   file_offset = (long) ptr-&gt;cur_start_row * bytesperrow;</span>
<span class="lineNum">     694 </span>            :   /* Loop to read or write each allocation chunk in mem_buffer */
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {</span>
<span class="lineNum">     696 </span>            :     /* One chunk, but check for short chunk at end of buffer */
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);</span>
<span class="lineNum">     698 </span>            :     /* Transfer no more than is currently defined */
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     thisrow = (long) ptr-&gt;cur_start_row + i;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);</span>
<span class="lineNum">     701 </span>            :     /* Transfer no more than fits in file */
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     if (rows &lt;= 0)           /* this chunk might be past end of file! */</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     byte_count = rows * bytesperrow;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     if (writing)</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :                                             (void FAR *) ptr-&gt;mem_buffer[i],</span>
<span class="lineNum">     709 </span>            :                                             file_offset, byte_count);
<span class="lineNum">     710 </span>            :     else
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :                                            (void FAR *) ptr-&gt;mem_buffer[i],</span>
<span class="lineNum">     713 </span>            :                                            file_offset, byte_count);
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :     file_offset += byte_count;</span>
<span class="lineNum">     715 </span>            :   }
<span class="lineNum">     716 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     717 </span>            : 
<a name="718"><span class="lineNum">     718 </span>            : </a>
<span class="lineNum">     719 </span>            : LOCAL(void)
<span class="lineNum">     720 </span><span class="lineNoCov">          0 : do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)</span>
<span class="lineNum">     721 </span>            : /* Do backing store read or write of a virtual coefficient-block array */
<span class="lineNum">     722 </span>            : {
<span class="lineNum">     723 </span>            :   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   bytesperrow = (long) ptr-&gt;blocksperrow * SIZEOF(JBLOCK);</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :   file_offset = (long) ptr-&gt;cur_start_row * bytesperrow;</span>
<span class="lineNum">     727 </span>            :   /* Loop to read or write each allocation chunk in mem_buffer */
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {</span>
<span class="lineNum">     729 </span>            :     /* One chunk, but check for short chunk at end of buffer */
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);</span>
<span class="lineNum">     731 </span>            :     /* Transfer no more than is currently defined */
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     thisrow = (long) ptr-&gt;cur_start_row + i;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);</span>
<span class="lineNum">     734 </span>            :     /* Transfer no more than fits in file */
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     if (rows &lt;= 0)           /* this chunk might be past end of file! */</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     byte_count = rows * bytesperrow;</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     if (writing)</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :                                             (void FAR *) ptr-&gt;mem_buffer[i],</span>
<span class="lineNum">     742 </span>            :                                             file_offset, byte_count);
<span class="lineNum">     743 </span>            :     else
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                                            (void FAR *) ptr-&gt;mem_buffer[i],</span>
<span class="lineNum">     746 </span>            :                                            file_offset, byte_count);
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     file_offset += byte_count;</span>
<span class="lineNum">     748 </span>            :   }
<span class="lineNum">     749 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     750 </span>            : 
<a name="751"><span class="lineNum">     751 </span>            : </a>
<span class="lineNum">     752 </span>            : METHODDEF(JSAMPARRAY)
<span class="lineNum">     753 </span><span class="lineNoCov">          0 : access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,</span>
<span class="lineNum">     754 </span>            :                     JDIMENSION start_row, JDIMENSION num_rows,
<span class="lineNum">     755 </span>            :                     boolean writable)
<span class="lineNum">     756 </span>            : /* Access the part of a virtual sample array starting at start_row */
<span class="lineNum">     757 </span>            : /* and extending for num_rows rows.  writable is true if  */
<span class="lineNum">     758 </span>            : /* caller intends to modify the accessed area. */
<span class="lineNum">     759 </span>            : {
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :   JDIMENSION end_row = start_row + num_rows;</span>
<span class="lineNum">     761 </span>            :   JDIMENSION undef_row;
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :   /* debugging check */
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :       ptr-&gt;mem_buffer == NULL)</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);</span>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            :   /* Make the desired part of the virtual array accessible */
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   if (start_row &lt; ptr-&gt;cur_start_row ||</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :       end_row &gt; ptr-&gt;cur_start_row + ptr-&gt;rows_in_mem) {</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     if (! ptr-&gt;b_s_open)</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :       ERREXIT(cinfo, JERR_VIRTUAL_BUG);</span>
<span class="lineNum">     773 </span>            :     /* Flush old buffer contents if necessary */
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     if (ptr-&gt;dirty) {</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :       do_sarray_io(cinfo, ptr, TRUE);</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :       ptr-&gt;dirty = FALSE;</span>
<span class="lineNum">     777 </span>            :     }
<span class="lineNum">     778 </span>            :     /* Decide what part of virtual array to access.
<span class="lineNum">     779 </span>            :      * Algorithm: if target address &gt; current window, assume forward scan,
<span class="lineNum">     780 </span>            :      * load starting at target address.  If target address &lt; current window,
<span class="lineNum">     781 </span>            :      * assume backward scan, load so that target area is top of window.
<span class="lineNum">     782 </span>            :      * Note that when switching from forward write to forward read, will have
<span class="lineNum">     783 </span>            :      * start_row = 0, so the limiting case applies and we load from 0 anyway.
<span class="lineNum">     784 </span>            :      */
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     if (start_row &gt; ptr-&gt;cur_start_row) {</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :       ptr-&gt;cur_start_row = start_row;</span>
<span class="lineNum">     787 </span>            :     } else {
<span class="lineNum">     788 </span>            :       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
<span class="lineNum">     789 </span>            :       long ltemp;
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :       ltemp = (long) end_row - (long) ptr-&gt;rows_in_mem;</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :       if (ltemp &lt; 0)</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         ltemp = 0;              /* don't fall off front end of file */</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :       ptr-&gt;cur_start_row = (JDIMENSION) ltemp;</span>
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            :     /* Read in the selected part of the array.
<span class="lineNum">     797 </span>            :      * During the initial write pass, we will do no actual read
<span class="lineNum">     798 </span>            :      * because the selected part is all undefined.
<span class="lineNum">     799 </span>            :      */
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     do_sarray_io(cinfo, ptr, FALSE);</span>
<span class="lineNum">     801 </span>            :   }
<span class="lineNum">     802 </span>            :   /* Ensure the accessed part of the array is defined; prezero if needed.
<span class="lineNum">     803 </span>            :    * To improve locality of access, we only prezero the part of the array
<span class="lineNum">     804 </span>            :    * that the caller is about to access, not the entire in-memory array.
<span class="lineNum">     805 </span>            :    */
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   if (ptr-&gt;first_undef_row &lt; end_row) {</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     if (ptr-&gt;first_undef_row &lt; start_row) {</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :       if (writable)             /* writer skipped over a section of array */</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :       undef_row = start_row;    /* but reader is allowed to read ahead */</span>
<span class="lineNum">     811 </span>            :     } else {
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :       undef_row = ptr-&gt;first_undef_row;</span>
<span class="lineNum">     813 </span>            :     }
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     if (writable)</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :       ptr-&gt;first_undef_row = end_row;</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     if (ptr-&gt;pre_zero) {</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       size_t bytesperrow = (size_t) ptr-&gt;samplesperrow * SIZEOF(JSAMPLE);</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :       undef_row -= ptr-&gt;cur_start_row; /* make indexes relative to buffer */</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :       end_row -= ptr-&gt;cur_start_row;</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :       while (undef_row &lt; end_row) {</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         FMEMZERO((void FAR *) ptr-&gt;mem_buffer[undef_row], bytesperrow);</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         undef_row++;</span>
<span class="lineNum">     823 </span>            :       }
<span class="lineNum">     824 </span>            :     } else {
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :       if (! writable)           /* reader looking at undefined data */</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :         ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);</span>
<span class="lineNum">     827 </span>            :     }
<span class="lineNum">     828 </span>            :   }
<span class="lineNum">     829 </span>            :   /* Flag the buffer dirty if caller will write in it */
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   if (writable)</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     ptr-&gt;dirty = TRUE;</span>
<span class="lineNum">     832 </span>            :   /* Return address of proper part of the buffer */
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   return ptr-&gt;mem_buffer + (start_row - ptr-&gt;cur_start_row);</span>
<span class="lineNum">     834 </span>            : }
<span class="lineNum">     835 </span>            : 
<a name="836"><span class="lineNum">     836 </span>            : </a>
<span class="lineNum">     837 </span>            : METHODDEF(JBLOCKARRAY)
<span class="lineNum">     838 </span><span class="lineNoCov">          0 : access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,</span>
<span class="lineNum">     839 </span>            :                     JDIMENSION start_row, JDIMENSION num_rows,
<span class="lineNum">     840 </span>            :                     boolean writable)
<span class="lineNum">     841 </span>            : /* Access the part of a virtual block array starting at start_row */
<span class="lineNum">     842 </span>            : /* and extending for num_rows rows.  writable is true if  */
<span class="lineNum">     843 </span>            : /* caller intends to modify the accessed area. */
<span class="lineNum">     844 </span>            : {
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :   JDIMENSION end_row = start_row + num_rows;</span>
<span class="lineNum">     846 </span>            :   JDIMENSION undef_row;
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :   /* debugging check */
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :       ptr-&gt;mem_buffer == NULL)</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);</span>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            :   /* Make the desired part of the virtual array accessible */
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :   if (start_row &lt; ptr-&gt;cur_start_row ||</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :       end_row &gt; ptr-&gt;cur_start_row + ptr-&gt;rows_in_mem) {</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     if (! ptr-&gt;b_s_open)</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :       ERREXIT(cinfo, JERR_VIRTUAL_BUG);</span>
<span class="lineNum">     858 </span>            :     /* Flush old buffer contents if necessary */
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     if (ptr-&gt;dirty) {</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :       do_barray_io(cinfo, ptr, TRUE);</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :       ptr-&gt;dirty = FALSE;</span>
<span class="lineNum">     862 </span>            :     }
<span class="lineNum">     863 </span>            :     /* Decide what part of virtual array to access.
<span class="lineNum">     864 </span>            :      * Algorithm: if target address &gt; current window, assume forward scan,
<span class="lineNum">     865 </span>            :      * load starting at target address.  If target address &lt; current window,
<span class="lineNum">     866 </span>            :      * assume backward scan, load so that target area is top of window.
<span class="lineNum">     867 </span>            :      * Note that when switching from forward write to forward read, will have
<span class="lineNum">     868 </span>            :      * start_row = 0, so the limiting case applies and we load from 0 anyway.
<span class="lineNum">     869 </span>            :      */
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     if (start_row &gt; ptr-&gt;cur_start_row) {</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :       ptr-&gt;cur_start_row = start_row;</span>
<span class="lineNum">     872 </span>            :     } else {
<span class="lineNum">     873 </span>            :       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
<span class="lineNum">     874 </span>            :       long ltemp;
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :       ltemp = (long) end_row - (long) ptr-&gt;rows_in_mem;</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :       if (ltemp &lt; 0)</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :         ltemp = 0;              /* don't fall off front end of file */</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :       ptr-&gt;cur_start_row = (JDIMENSION) ltemp;</span>
<span class="lineNum">     880 </span>            :     }
<span class="lineNum">     881 </span>            :     /* Read in the selected part of the array.
<span class="lineNum">     882 </span>            :      * During the initial write pass, we will do no actual read
<span class="lineNum">     883 </span>            :      * because the selected part is all undefined.
<span class="lineNum">     884 </span>            :      */
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     do_barray_io(cinfo, ptr, FALSE);</span>
<span class="lineNum">     886 </span>            :   }
<span class="lineNum">     887 </span>            :   /* Ensure the accessed part of the array is defined; prezero if needed.
<span class="lineNum">     888 </span>            :    * To improve locality of access, we only prezero the part of the array
<span class="lineNum">     889 </span>            :    * that the caller is about to access, not the entire in-memory array.
<span class="lineNum">     890 </span>            :    */
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :   if (ptr-&gt;first_undef_row &lt; end_row) {</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     if (ptr-&gt;first_undef_row &lt; start_row) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       if (writable)             /* writer skipped over a section of array */</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :       undef_row = start_row;    /* but reader is allowed to read ahead */</span>
<span class="lineNum">     896 </span>            :     } else {
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :       undef_row = ptr-&gt;first_undef_row;</span>
<span class="lineNum">     898 </span>            :     }
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     if (writable)</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :       ptr-&gt;first_undef_row = end_row;</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     if (ptr-&gt;pre_zero) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :       size_t bytesperrow = (size_t) ptr-&gt;blocksperrow * SIZEOF(JBLOCK);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :       undef_row -= ptr-&gt;cur_start_row; /* make indexes relative to buffer */</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :       end_row -= ptr-&gt;cur_start_row;</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :       while (undef_row &lt; end_row) {</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :         FMEMZERO((void FAR *) ptr-&gt;mem_buffer[undef_row], bytesperrow);</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :         undef_row++;</span>
<span class="lineNum">     908 </span>            :       }
<span class="lineNum">     909 </span>            :     } else {
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :       if (! writable)           /* reader looking at undefined data */</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :         ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);</span>
<span class="lineNum">     912 </span>            :     }
<span class="lineNum">     913 </span>            :   }
<span class="lineNum">     914 </span>            :   /* Flag the buffer dirty if caller will write in it */
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   if (writable)</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     ptr-&gt;dirty = TRUE;</span>
<span class="lineNum">     917 </span>            :   /* Return address of proper part of the buffer */
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   return ptr-&gt;mem_buffer + (start_row - ptr-&gt;cur_start_row);</span>
<span class="lineNum">     919 </span>            : }
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            : /*
<span class="lineNum">     923 </span>            :  * Release all objects belonging to a specified pool.
<span class="lineNum">     924 </span>            :  */
<a name="925"><span class="lineNum">     925 </span>            : </a>
<span class="lineNum">     926 </span>            : METHODDEF(void)
<span class="lineNum">     927 </span><span class="lineNoCov">          0 : free_pool (j_common_ptr cinfo, int pool_id)</span>
<span class="lineNum">     928 </span>            : {
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;</span>
<span class="lineNum">     930 </span>            :   small_pool_ptr shdr_ptr;
<span class="lineNum">     931 </span>            :   large_pool_ptr lhdr_ptr;
<span class="lineNum">     932 </span>            :   size_t space_freed;
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */</span>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            : #ifdef MEM_STATS
<span class="lineNum">     938 </span>            :   if (cinfo-&gt;err-&gt;trace_level &gt; 1)
<span class="lineNum">     939 </span>            :     print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
<span class="lineNum">     940 </span>            : #endif
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            :   /* If freeing IMAGE pool, close any virtual arrays first */
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :   if (pool_id == JPOOL_IMAGE) {</span>
<span class="lineNum">     944 </span>            :     jvirt_sarray_ptr sptr;
<span class="lineNum">     945 </span>            :     jvirt_barray_ptr bptr;
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :       if (sptr-&gt;b_s_open) {  /* there may be no backing store */</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :         sptr-&gt;b_s_open = FALSE;      /* prevent recursive close if error */</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         (*sptr-&gt;b_s_info.close_backing_store) (cinfo, &amp; sptr-&gt;b_s_info);</span>
<span class="lineNum">     951 </span>            :       }
<span class="lineNum">     952 </span>            :     }
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     mem-&gt;virt_sarray_list = NULL;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :       if (bptr-&gt;b_s_open) {  /* there may be no backing store */</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         bptr-&gt;b_s_open = FALSE;      /* prevent recursive close if error */</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         (*bptr-&gt;b_s_info.close_backing_store) (cinfo, &amp; bptr-&gt;b_s_info);</span>
<span class="lineNum">     958 </span>            :       }
<span class="lineNum">     959 </span>            :     }
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     mem-&gt;virt_barray_list = NULL;</span>
<span class="lineNum">     961 </span>            :   }
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            :   /* Release large objects */
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :   lhdr_ptr = mem-&gt;large_list[pool_id];</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   mem-&gt;large_list[pool_id] = NULL;</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :   while (lhdr_ptr != NULL) {</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     large_pool_ptr next_lhdr_ptr = lhdr_ptr-&gt;hdr.next;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     space_freed = lhdr_ptr-&gt;hdr.bytes_used +</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :                   lhdr_ptr-&gt;hdr.bytes_left +</span>
<span class="lineNum">     971 </span>            :                   SIZEOF(large_pool_hdr);
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     mem-&gt;total_space_allocated -= space_freed;</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     lhdr_ptr = next_lhdr_ptr;</span>
<span class="lineNum">     975 </span>            :   }
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :   /* Release small objects */
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   shdr_ptr = mem-&gt;small_list[pool_id];</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   mem-&gt;small_list[pool_id] = NULL;</span>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   while (shdr_ptr != NULL) {</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :     small_pool_ptr next_shdr_ptr = shdr_ptr-&gt;hdr.next;</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     space_freed = shdr_ptr-&gt;hdr.bytes_used +</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                   shdr_ptr-&gt;hdr.bytes_left +</span>
<span class="lineNum">     985 </span>            :                   SIZEOF(small_pool_hdr);
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     mem-&gt;total_space_allocated -= space_freed;</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     shdr_ptr = next_shdr_ptr;</span>
<span class="lineNum">     989 </span>            :   }
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            : /*
<span class="lineNum">     994 </span>            :  * Close up shop entirely.
<span class="lineNum">     995 </span>            :  * Note that this cannot be called unless cinfo-&gt;mem is non-NULL.
<span class="lineNum">     996 </span>            :  */
<a name="997"><span class="lineNum">     997 </span>            : </a>
<span class="lineNum">     998 </span>            : METHODDEF(void)
<span class="lineNum">     999 </span><span class="lineNoCov">          0 : self_destruct (j_common_ptr cinfo)</span>
<span class="lineNum">    1000 </span>            : {
<span class="lineNum">    1001 </span>            :   int pool;
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span>            :   /* Close all backing store, release all memory.
<span class="lineNum">    1004 </span>            :    * Releasing pools in reverse order might help avoid fragmentation
<span class="lineNum">    1005 </span>            :    * with some (brain-damaged) malloc libraries.
<span class="lineNum">    1006 </span>            :    */
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   for (pool = JPOOL_NUMPOOLS-1; pool &gt;= JPOOL_PERMANENT; pool--) {</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     free_pool(cinfo, pool);</span>
<span class="lineNum">    1009 </span>            :   }
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :   /* Release the memory manager control block too. */
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   jpeg_free_small(cinfo, (void *) cinfo-&gt;mem, SIZEOF(my_memory_mgr));</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   cinfo-&gt;mem = NULL;         /* ensures I will be called only once */</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   jpeg_mem_term(cinfo);         /* system-dependent cleanup */</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : /*
<span class="lineNum">    1020 </span>            :  * Memory manager initialization.
<span class="lineNum">    1021 </span>            :  * When this is called, only the error manager pointer is valid in cinfo!
<span class="lineNum">    1022 </span>            :  */
<a name="1023"><span class="lineNum">    1023 </span>            : </a>
<span class="lineNum">    1024 </span>            : GLOBAL(void)
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 : jinit_memory_mgr (j_common_ptr cinfo)</span>
<span class="lineNum">    1026 </span>            : {
<span class="lineNum">    1027 </span>            :   my_mem_ptr mem;
<span class="lineNum">    1028 </span>            :   long max_to_use;
<span class="lineNum">    1029 </span>            :   int pool;
<span class="lineNum">    1030 </span>            :   size_t test_mac;
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   cinfo-&gt;mem = NULL;         /* for safety if init fails */</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :   /* Check for configuration errors.
<span class="lineNum">    1035 </span>            :    * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
<span class="lineNum">    1036 </span>            :    * doesn't reflect any real hardware alignment requirement.
<span class="lineNum">    1037 </span>            :    * The test is a little tricky: for X&gt;0, X and X-1 have no one-bits
<span class="lineNum">    1038 </span>            :    * in common if and only if X is a power of 2, ie has only one one-bit.
<span class="lineNum">    1039 </span>            :    * Some compilers may give an &quot;unreachable code&quot; warning here; ignore it.
<span class="lineNum">    1040 </span>            :    */
<span class="lineNum">    1041 </span>            :   if ((SIZEOF(ALIGN_TYPE) &amp; (SIZEOF(ALIGN_TYPE)-1)) != 0)
<span class="lineNum">    1042 </span>            :     ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
<span class="lineNum">    1043 </span>            :   /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
<span class="lineNum">    1044 </span>            :    * a multiple of SIZEOF(ALIGN_TYPE).
<span class="lineNum">    1045 </span>            :    * Again, an &quot;unreachable code&quot; warning may be ignored here.
<span class="lineNum">    1046 </span>            :    * But a &quot;constant too large&quot; warning means you need to fix MAX_ALLOC_CHUNK.
<span class="lineNum">    1047 </span>            :    */
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :   test_mac = (size_t) MAX_ALLOC_CHUNK;</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   if ((long) test_mac != MAX_ALLOC_CHUNK ||</span>
<span class="lineNum">    1050 </span>            :       (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */</span>
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span>            :   /* Attempt to allocate memory manager's control block */
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   if (mem == NULL) {</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     jpeg_mem_term(cinfo);       /* system-dependent cleanup */</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :     ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);</span>
<span class="lineNum">    1061 </span>            :   }
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            :   /* OK, fill in the method pointers */
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   mem-&gt;pub.alloc_small = alloc_small;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   mem-&gt;pub.alloc_large = alloc_large;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   mem-&gt;pub.alloc_sarray = alloc_sarray;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :   mem-&gt;pub.alloc_barray = alloc_barray;</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :   mem-&gt;pub.request_virt_sarray = request_virt_sarray;</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   mem-&gt;pub.request_virt_barray = request_virt_barray;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   mem-&gt;pub.realize_virt_arrays = realize_virt_arrays;</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :   mem-&gt;pub.access_virt_sarray = access_virt_sarray;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   mem-&gt;pub.access_virt_barray = access_virt_barray;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   mem-&gt;pub.free_pool = free_pool;</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   mem-&gt;pub.self_destruct = self_destruct;</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            :   /* Make MAX_ALLOC_CHUNK accessible to other modules */
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :   mem-&gt;pub.max_alloc_chunk = MAX_ALLOC_CHUNK;</span>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            :   /* Initialize working state */
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   mem-&gt;pub.max_memory_to_use = max_to_use;</span>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :   for (pool = JPOOL_NUMPOOLS-1; pool &gt;= JPOOL_PERMANENT; pool--) {</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     mem-&gt;small_list[pool] = NULL;</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :     mem-&gt;large_list[pool] = NULL;</span>
<span class="lineNum">    1085 </span>            :   }
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :   mem-&gt;virt_sarray_list = NULL;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :   mem-&gt;virt_barray_list = NULL;</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   mem-&gt;total_space_allocated = SIZEOF(my_memory_mgr);</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :   /* Declare ourselves open for business */
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   cinfo-&gt;mem = &amp;mem-&gt;pub;</span>
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            :   /* Check for an environment variable JPEGMEM; if found, override the
<span class="lineNum">    1095 </span>            :    * default max_memory setting from jpeg_mem_init.  Note that the
<span class="lineNum">    1096 </span>            :    * surrounding application may again override this value.
<span class="lineNum">    1097 </span>            :    * If your system doesn't support getenv(), define NO_GETENV to disable
<span class="lineNum">    1098 </span>            :    * this feature.
<span class="lineNum">    1099 </span>            :    */
<span class="lineNum">    1100 </span>            : #ifndef NO_GETENV
<span class="lineNum">    1101 </span>            :   { char * memenv;
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :     if ((memenv = getenv(&quot;JPEGMEM&quot;)) != NULL) {</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :       char ch = 'x';</span>
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :       if (sscanf(memenv, &quot;%ld%c&quot;, &amp;max_to_use, &amp;ch) &gt; 0) {</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         if (ch == 'm' || ch == 'M')</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :           max_to_use *= 1000L;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :         mem-&gt;pub.max_memory_to_use = max_to_use * 1000L;</span>
<span class="lineNum">    1110 </span>            :       }
<span class="lineNum">    1111 </span>            :     }
<span class="lineNum">    1112 </span>            :   }
<span class="lineNum">    1113 </span>            : #endif
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
